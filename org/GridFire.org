#+TITLE: The GridFire Fire Behavior Model
#+AUTHOR: Gary W. Johnson, Ph.D., David Saah, Ph.D., Max Moritz, Ph.D., Kenneth Cheung
#+DATE: Copyright Â© 2014-2022 Spatial Informatics Group, LLC
#+OPTIONS: ^:{} toc:nil h:3
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in]{geometry}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage{epsfig}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage[round,comma]{natbib}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \setlength{\headheight}{13.6pt}
#+LATEX_HEADER: \hypersetup{
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     linkbordercolor=black,
#+LATEX_HEADER:     linkcolor=black}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \graphicspath{{../resources/}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{394}{$\Delta$}
#+LATEX_HEADER: \DeclareUnicodeCharacter{3C7}{$\chi$}

* Preface

This document is a Literate
Program[fn::https://en.wikipedia.org/wiki/Literate_programming],
containing both the source code of the software it describes as well
as the rationale used in each step of its design and implementation.
The purpose of this approach is to enable anyone sufficiently
experienced in programming to easily retrace the author's footsteps as
they read through the text and code. By the time they have reached the
end of this document, the reader should have just as strong a grasp of
the system as the original programmer.

To execute the code illustrated within this document, you will need to
install several pieces of software, all of which are open source
and/or freely available for all major operating systems. These
programs are listed in Table [[tab:required-software]] along with their
minimum required versions and URLs from which they may be downloaded.

#+NAME: tab:required-software
#+CAPTION: Software necessary to evaluate the code in this document
#+ATTR_LATEX: :align |l|r|l| :font \small
|----------------------+---------+--------------------------------------------|
| Name                 | Version | URL                                        |
|----------------------+---------+--------------------------------------------|
| Java Development Kit |     11+ | https://jdk.java.net                       |
| Clojure CLI Tools    |   1.10+ | https://clojure.org/guides/getting_started |
| Postgresql           |     10+ | https://www.postgresql.org/download        |
| PostGIS              |      3+ | https://postgis.net/install                |
| GDAL                 |      3+ | https://gdal.org                           |
|----------------------+---------+--------------------------------------------|

GridFire is written in the Clojure programming
language[fn::https://clojure.org], which is a modern dialect of Lisp
hosted on the Java Virtual Machine.\citep{Hickey2008} As a result, a
Java Development Kit is required to compile and run the code shown
throughout this document.

The Clojure CLI tools are used to download required libraries and
provide a code evaluation prompt (a.k.a. REPL) into which we will
enter the code making up this fire model.

Postgresql (along with the PostGIS spatial extensions) will be used to
load and serve raster-formatted GIS layers to the GridFire program.
Although it is beyond the scope of this document,
PostGIS[fn::https://postgis.net] provides a rich API for manipulating
both raster and vector layers through SQL.

*License Notice*: All code presented in this document is solely the
work of the authors (Gary W. Johnson, Ph.D., David Saah, Ph.D., Max
Moritz, Ph.D., Kenneth Cheung) and is made available by Spatial
Informatics Group, LLC (SIG) under the Eclipse Public License version
2.0 (EPLv2).[fn::https://www.eclipse.org/legal/epl-2.0/] See
LICENSE.txt in the top level directory of this repository for details.
Please contact Gary Johnson (gjohnson@sig-gis.com), David Saah
(dsaah@sig-gis.com), Max Moritz (mmoritz@sig-gis.com), or Kenneth
Cheung (kcheung@sig-gis.com) for further information about this
software.

* Setting Up the Clojure Environment

Because Clojure is implemented on the Java Virtual Machine (JVM), we
must explicitly list all of the libraries used by our program on the
Java classpath. Fortunately, the Clojure CLI tools can handle
downloading and storing these libraries as well as making them
available to the Clojure process at runtime. However, in order for
Clojure to know which libraries are needed, we must first create its
build configuration file, called ``deps.edn'', and place it in the
directory from which we will call our Clojure program. The complete
deps.edn for the current GridFire version is shown below.

#+name: deps.edn
#+begin_src clojure :results silent :exports code :tangle ../deps.edn :padline no :no-expand :comments link
{:paths ["src" "resources"]

 :deps {cnuernber/dtype-next                {:mvn/version "9.000"}
        commons-codec/commons-codec         {:mvn/version "1.15"}
        com.nextjournal/beholder            {:mvn/version "1.0.0"}
        com.taoensso/tufte                  {:mvn/version "2.2.0"}
        hikari-cp/hikari-cp                 {:mvn/version "2.13.0"}
        org.clojars.lambdatronic/matrix-viz {:mvn/version "2022.02.03"}
        org.clojure/clojure                 {:mvn/version "1.10.3"}
        org.clojure/core.async              {:mvn/version "1.3.622"}
        org.clojure/data.csv                {:mvn/version "1.0.0"}
        org.clojure/data.json               {:mvn/version "2.4.0"}
        org.clojure/java.jdbc               {:mvn/version "0.7.12"}
        org.clojure/tools.cli               {:mvn/version "1.0.206"}
        org.postgresql/postgresql           {:mvn/version "42.2.23"}
        sig-gis/magellan                    {:mvn/version "2022.03.18"}
        sig-gis/triangulum                  {:git/url "https://github.com/sig-gis/triangulum"
                                             :sha     "5b179a97ebd8fbcbff51776db06d9770cb649b9d"}}

 :mvn/repos {"osgeo" {:url "https://repo.osgeo.org/repository/release/"}}

 :aliases {:build-test-db     {:extra-paths ["test"]
                               :main-opts   ["-m" "gridfire.build-test-db"]}
           :run               {:main-opts ["-m" "gridfire.cli"]
                               :jvm-opts  ["-XX:MaxRAMPercentage=90"]}
           :repl              {:main-opts ["-e" "(require,'gridfire.core)"
                                           "-e" "(in-ns,'gridfire.core)"
                                           "-r"]}
           :gen-raster        {:main-opts ["-m" "gridfire.gen-raster"]}
           :make-uberjar      {:replace-deps {com.github.seancorfield/depstar {:mvn/version "2.1.303"}}
                               :exec-fn      hf.depstar/uberjar
                               :exec-args    {:jar         target/gridfire-2022.02.07.jar
                                              :main-class  gridfire.cli
                                              :aot         true
                                              :sync-pom    true
                                              :group-id    sig-gis
                                              :artifact-id gridfire
                                              :version     "2022.02.07"
                                              :manifest
                                              {:specification-title    "Java Advanced Imaging Image I/O Tools"
                                               :specification-version  "1.1"
                                               :specification-vendor   "Sun Microsystems, Inc."
                                               :implementation-title   "com.sun.media.imageio"
                                               :implementation-version "1.1"
                                               :implementation-vendor  "Sun Microsystems, Inc."}}}
           :test              {:extra-paths ["test"]
                               :extra-deps  {com.cognitect/test-runner
                                             {:git/url "https://github.com/cognitect-labs/test-runner.git"
                                              :sha     "dd6da11611eeb87f08780a30ac8ea6012d4c05ce"}}
                               :main-opts   ["-e" "(do,(set!,*warn-on-reflection*,true),nil)"
                                             "-m" "cognitect.test-runner"]}
           :test-unit         {:extra-paths ["test"]
                               :extra-deps  {com.cognitect/test-runner
                                             {:git/url "https://github.com/cognitect-labs/test-runner.git"
                                              :sha     "dd6da11611eeb87f08780a30ac8ea6012d4c05ce"}}
                               :main-opts   ["-e" "(do,(set!,*warn-on-reflection*,true),nil)"
                                             "-m" "cognitect.test-runner"
                                             "--include" ":unit"]}
           :check-reflections {:extra-paths ["test"]
                               :main-opts   ["-e" "(do,(set!,*warn-on-reflection*,true),nil)"
                                             "-e" "(require,'gridfire.cli)"
                                             "-e" "(require,'gridfire.build-test-db)"]}
           :check-deps        {:extra-deps {olical/depot {:mvn/version "2.3.0"}}
                               :main-opts  ["-m" "depot.outdated.main"]}}}
#+end_src

Once this file is created, we need to instruct Clojure to download
these library dependencies and then run the built-in test suite to
verify that GridFire compiles and runs as expected on our local
computer.

Before we run the tests, we'll need to set up a test database and
import some rasters into it. We will be prompted for the postgres and
gridfire_test users' passwords. The postgres user's password will be
whatever it is when we set up Postgresql. For the gridfire_test user's
password, refer to ``src/sql/create_test_db.sql''. The default value
is simply ``gridfire_test''.

The following command builds the test database:

#+name: clojure-test-db
#+begin_src sh :results silent :exports code
clojure -M:build-test-db
#+end_src

Once that has completed, you can run the following command to launch
the test suite:

#+name: clojure-test
#+begin_src sh :results silent :exports code
clojure -M:test
#+end_src

* Setting Up the PostGIS Database

GridFire may make use of any raster-formatted GIS layers that are
loaded into a PostGIS database. Therefore, we must begin by creating a
spatially-enabled database on our local Postgresql server.

When installing Postgresql, we should have been prompted to create an
initial superuser called *postgres*, who has full permissions to
create new databases and roles. We can log into the Postgresql server
as this user with the following *psql* command.

#+name: connect-to-postgresql-server-as-postgres
#+begin_src sh :results silent :exports code
psql -U postgres
#+end_src

Once logged in, we issue the following commands to first create a new
database role and to then create a new database (owned by this role)
in which to store our raster data. Finally, we import the PostGIS
spatial extensions into the new database.

#+name: create-gridfire-db
#+begin_src sql :engine postgresql :cmdline -U postgres :results silent :exports code
CREATE ROLE gridfire WITH LOGIN CREATEDB;
CREATE DATABASE gridfire WITH OWNER gridfire;
\c gridfire
CREATE EXTENSION postgis;
#+end_src

* Importing Rasters into the Database

Whenever we want to add a new raster-formatted GIS layer to our
database, we can simply issue the *raster2pgsql* command as follows,
replacing the raster name and table name to match our own datasets.

#+name: raster2pgsql-import-example-single
#+begin_src sh :results silent :exports code
SRID=4326
RASTER=dem.tif
TABLE=dem
DATABASE=gridfire
raster2pgsql -s $SRID $RASTER $TABLE | psql $DATABASE
#+end_src

*Note:* The raster2pgsql command has several useful command line
options, including automatic tiling of the raster layer in the
database, creating fast spatial indeces after import, or setting
raster constraints on the newly created table. Run *raster2pgsql -?*
from the command line for more details.

Here's an example shell script that will tile multiple large rasters
(asp.tif, cbd.tif, cbh.tif, etc) into 100x100 tiles and import them
into our database.

*Note:* Here we specified a schema (e.g, landfire) along with the table
name so as to match the sample config file in
``resources/sample_config.edn''.

First create the schema in our database.

#+name: create-landfire-schema
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
CREATE SCHEMA landfire;
#+end_src

Then we can use the following script to import LANDFIRE layers into
our database given the username and schema as inputs.

*Note:* This script needs to be run in the same folder as where these
rasters reside. The filenames of these rasters should match the
elements in the for loop (i.e. asp.tif, cbd.tif etc)
#+name: raster2pgsql-import-example-all
#+begin_src sh :results silent :exports code :tangle ../resources/import_landfire_rasters.sh :padline no :no-expand :comments link
#!/usr/bin/env bash

USERNAME=$1
SCHEMA=$2
SRID=$3

for LAYER in asp cbd cbh cc ch dem fbfm13 fbfm40 slp
do
    raster2pgsql -t auto -I -C -s $SRID $LAYER.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME
done
#+end_src

To run the script, give it our username, schema, and srid we wish the layers to
have.

#+begin_src sh
sh import_landfire_rasters.sh gridfire landfire 90914
#+end_src

Whenever we want to add a new spatial reference system to our
database, we can insert a record into our spatial_ref_sys table.

#+name: insert-spatial-reference-systems
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
INSERT INTO public.spatial_ref_sys (srid, auth_name, auth_srid, srtext, proj4text)
VALUES (900914, 'user-generated', 900914,
        'PROJCS["USA_Contiguous_Albers_Equal_Area_Conic_USGS_version",' ||
        'GEOGCS["NAD83",' ||
        'DATUM["North_American_Datum_1983",' ||
        'SPHEROID["GRS 1980",6378137,298.2572221010002,' ||
        'AUTHORITY["EPSG","7019"]],' ||
        'AUTHORITY["EPSG","6269"]],' ||
        'PRIMEM["Greenwich",0],' ||
        'UNIT["degree",0.0174532925199433],' ||
        'AUTHORITY["EPSG","4269"]],' ||
        'PROJECTION["Albers_Conic_Equal_Area"],' ||
        'PARAMETER["standard_parallel_1",29.5],' ||
        'PARAMETER["standard_parallel_2",45.5],' ||
        'PARAMETER["latitude_of_center",23],' ||
        'PARAMETER["longitude_of_center",-96],' ||
        'PARAMETER["false_easting",0],' ||
        'PARAMETER["false_northing",0],' ||
        'UNIT["metre",1,' ||
        'AUTHORITY["EPSG","9001"]]]',
        '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0' ||
        ' +datum=NAD83 +units=m +no_defs');
#+end_src

We may also want to import initial ignition rasters into our database.
We can do so with a similar script as importing LANDFIRE rasters.

First create a new schema.

#+name: create-ignition-schema
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
CREATE SCHEMA ignition;
#+end_src

Then we can use the following script to import an ignition raster into
our database given the schema and username as inputs.

*Note:* This script needs to be run in the same folder as where this
raster resides. The filename of this raster should match the value
assigned to the LAYER variable (i.e., ign) plus a .tif extension.

#+name: raster2pgsql-import-ignition-raster
#+begin_src sh :results silent :exports code :tangle ../resources/import_ignition_rasters.sh :padline no :no-expand :comments link
#!/usr/bin/env bash

USERNAME=$1
SCHEMA=$2
SRID=$3

LAYER="ign"
raster2pgsql -I -C -t auto -s $SRID $LAYER.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME
#+end_src

To run the script, give it the username, schema name, and srid we wish the layers to have.

#+begin_src bash
sh import_ignition_rasters.sh gridfire ignition 90014
#+end_src

We may also want to import weather rasters into our database.
We can do so with a similar script as importing LANDFIRE rasters.

First create a new schema.

#+name: create-weather-schema
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
CREATE SCHEMA weather;
#+end_src

Then we can use the following script to import weather rasters into
our database given the schema and username as inputs.

*Note:* This script needs to be run in the same folder as where this
rasters resides. The filename of these rasters should match the
elements in the for loop (i.e. tmpf_to_sample.tif)

#+name: raster2pgsql-import-weather-rasters
#+begin_src sh :results silent :exports code :tangle ../resources/import_weather_rasters.sh :padline no :no-expand :comments link
#!/usr/bin/env bash

USERNAME=$1
SCHEMA=$2
SRID=$3
TILING=$4

for LAYER in tmpf wd ws rh
do
    if [ -z "$TILING" ]
    then
        raster2pgsql -I -C -t auto -s $SRID ${LAYER}_to_sample.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME
    else
        raster2pgsql -I -C -t $TILING -s $SRID ${LAYER}_to_sample.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME

    fi
done
#+end_src

To run the script, give it the username, schema name, and srid we wish the layers to have.

#+begin_src bash
sh import_weather_rasters.sh gridfire weather 90014
#+end_src

You may optionally include a fourth argument to set the tiling (defaults to auto).

#+begin_src bash
sh import_weather_rasters.sh gridfire weather 90014 800x800
#+end_src

*Note:* This script needs to be run in the same folder as where these rasters reside.

* Fire Spread Model

GridFire implements the following fire behavior formulas from the fire
science literature:

- Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976
- Crown Fire Initiation: Van Wagner 1977
- Passive/Active Crown Fire Spread: Cruz 2005
- Flame Length and Fire Line Intensity: Byram 1959
- Midflame Wind Adjustment Factor: Albini & Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012\nocite{Albini1979,Andrews2012}
- Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)
- Spot Fire: Perryman 2013

The following fuel models are supported:

- Anderson 13: no dynamic loading
- Scott & Burgan 40: dynamic loading implemented according to Scott & Burgan 2005

The method used to translate linear fire spread rates to a
2-dimensional raster grid were originally developed by Marco Morais at
UCSB as part of his HFire
system.\citep{Peterson2011,Peterson2009,Morais2001} Detailed
information about this software, including its source code and
research article references can be found here:

  http://firecenter.berkeley.edu/hfire/about.html

Outputs from GridFire include fire size (ac), fire line intensity
(Btu/ft/s), flame length (ft), fire volume (ac*ft), fire shape (ac/ft)
and conditional burn probability (times burned/fires initiated). Fire
line intensity and flame length may both be exported as either average
values per fire or as maps of the individual values per burned cell.

In the following sections, we describe the operation of this system in
detail.

** Fuel Model Definitions

All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.

Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called ``fuel
models'' which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
[[tab:fuel-model-properties]].

#+NAME: tab:fuel-model-properties
#+CAPTION: Physical properties assigned to each fuel model
#+ATTR_LATEX: :align |l|l|l| :font \small
|----------+--------------------------------------------+-----------------------------------------|
| Property | Description                                | Units                                   |
|----------+--------------------------------------------+-----------------------------------------|
| \delta   | fuel depth                                 | ft                                      |
| w_{o}    | ovendry fuel loading                       | lb/ft^{2}                               |
| \sigma   | fuel particle surface-area-to-volume ratio | ft^{2}/ft^{3}                           |
| M_{x}    | moisture content of extinction             | lb moisture/lb ovendry wood             |
| h        | fuel particle low heat content             | Btu/lb                                  |
| \rho_{p} | ovendry particle density                   | lb/ft^{3}                               |
| S_{T}    | fuel particle total mineral content        | lb minerals/lb ovendry wood             |
| S_{e}    | fuel particle effective mineral content    | lb silica-free minerals/lb ovendry wood |
| M_{f}    | fuel particle moisture content             | lb moisture/lb ovendry wood             |
|----------+--------------------------------------------+-----------------------------------------|

*Note:* While M_{f} is not, in fact, directly assigned to any of these
fuel models, their definitions remain incomplete for the purposes of
fire spread modelling (particularly those reliant on the curing
formulas of dynamic fuel loading) until it is provided as a
characteristic of local weather conditions.

The fuel models supported by GridFire include the standard 13 fuel
models of Rothermel, Albini, and Anderson\citep{Anderson1982} and the
additional 40 fuel models defined by Scott and
Burgan\citep{Scott2005}. These are all concisely encoded in an
internal data structure, which may be updated to include additional
custom fuel models desired by the user.

#+name: fuel-model-definitions
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :padline no :no-expand :comments link
(ns gridfire.fuel-models-optimal)

(set! *unchecked-math* :warn-on-boxed)

(def fuel-models
  "Lookup table including one entry for each of the Anderson 13 and
   Scott & Burgan 40 fuel models. The fields have the following
   meanings:
   {fuel-model-number
    [name delta M_x-dead h
     [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr w_o-live-herbaceous w_o-live-woody]
     [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr sigma-live-herbaceous sigma-live-woody]]
   }"
  {
   ;; Anderson 13:
   ;; Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)
   1   [:R01 1.0 12 8 [0.0340 0.0000 0.0000 0.0000 0.0000] [3500.0   0.0  0.0    0.0    0.0]]
   2   [:R02 1.0 15 8 [0.0920 0.0460 0.0230 0.0230 0.0000] [3000.0 109.0 30.0 1500.0    0.0]]
   3   [:R03 2.5 25 8 [0.1380 0.0000 0.0000 0.0000 0.0000] [1500.0   0.0  0.0    0.0    0.0]]
   ;; Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)
   4   [:R04 6.0 20 8 [0.2300 0.1840 0.0920 0.2300 0.0000] [2000.0 109.0 30.0 1500.0    0.0]]
   5   [:R05 2.0 20 8 [0.0460 0.0230 0.0000 0.0920 0.0000] [2000.0 109.0  0.0 1500.0    0.0]]
   6   [:R06 2.5 25 8 [0.0690 0.1150 0.0920 0.0000 0.0000] [1750.0 109.0 30.0    0.0    0.0]]
   7   [:R07 2.5 40 8 [0.0520 0.0860 0.0690 0.0170 0.0000] [1750.0 109.0 30.0 1550.0    0.0]]
   ;; Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)
   8   [:R08 0.2 30 8 [0.0690 0.0460 0.1150 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   9   [:R09 0.2 25 8 [0.1340 0.0190 0.0070 0.0000 0.0000] [2500.0 109.0 30.0    0.0    0.0]]
   10  [:R10 1.0 25 8 [0.1380 0.0920 0.2300 0.0920 0.0000] [2000.0 109.0 30.0 1500.0    0.0]]
   ;; Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)
   11  [:R11 1.0 15 8 [0.0690 0.2070 0.2530 0.0000 0.0000] [1500.0 109.0 30.0    0.0    0.0]]
   12  [:R12 2.3 20 8 [0.1840 0.6440 0.7590 0.0000 0.0000] [1500.0 109.0 30.0    0.0    0.0]]
   13  [:R13 3.0 25 8 [0.3220 1.0580 1.2880 0.0000 0.0000] [1500.0 109.0 30.0    0.0    0.0]]
   ;; Nonburnable (NB)
   91  [:NB1 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   92  [:NB2 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   93  [:NB3 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   98  [:NB4 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   99  [:NB5 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   ;; Scott & Burgan 40:
   ;; Grass (GR)
   101 [:GR1 0.4 15 8 [0.0046 0.0000 0.0000 0.0138 0.0000] [2200.0 109.0 30.0 2000.0    0.0]]
   102 [:GR2 1.0 15 8 [0.0046 0.0000 0.0000 0.0459 0.0000] [2000.0 109.0 30.0 1800.0    0.0]]
   103 [:GR3 2.0 30 8 [0.0046 0.0184 0.0000 0.0689 0.0000] [1500.0 109.0 30.0 1300.0    0.0]]
   104 [:GR4 2.0 15 8 [0.0115 0.0000 0.0000 0.0872 0.0000] [2000.0 109.0 30.0 1800.0    0.0]]
   105 [:GR5 1.5 40 8 [0.0184 0.0000 0.0000 0.1148 0.0000] [1800.0 109.0 30.0 1600.0    0.0]]
   106 [:GR6 1.5 40 9 [0.0046 0.0000 0.0000 0.1561 0.0000] [2200.0 109.0 30.0 2000.0    0.0]]
   107 [:GR7 3.0 15 8 [0.0459 0.0000 0.0000 0.2479 0.0000] [2000.0 109.0 30.0 1800.0    0.0]]
   108 [:GR8 4.0 30 8 [0.0230 0.0459 0.0000 0.3352 0.0000] [1500.0 109.0 30.0 1300.0    0.0]]
   109 [:GR9 5.0 40 8 [0.0459 0.0459 0.0000 0.4132 0.0000] [1800.0 109.0 30.0 1600.0    0.0]]
   ;; Grass-Shrub (GS)
   121 [:GS1 0.9 15 8 [0.0092 0.0000 0.0000 0.0230 0.0298] [2000.0 109.0 30.0 1800.0 1800.0]]
   122 [:GS2 1.5 15 8 [0.0230 0.0230 0.0000 0.0275 0.0459] [2000.0 109.0 30.0 1800.0 1800.0]]
   123 [:GS3 1.8 40 8 [0.0138 0.0115 0.0000 0.0666 0.0574] [1800.0 109.0 30.0 1600.0 1600.0]]
   124 [:GS4 2.1 40 8 [0.0872 0.0138 0.0046 0.1561 0.3260] [1800.0 109.0 30.0 1600.0 1600.0]]
   ;; Shrub (SH)
   141 [:SH1 1.0 15 8 [0.0115 0.0115 0.0000 0.0069 0.0597] [2000.0 109.0 30.0 1800.0 1600.0]]
   142 [:SH2 1.0 15 8 [0.0620 0.1102 0.0344 0.0000 0.1768] [2000.0 109.0 30.0    0.0 1600.0]]
   143 [:SH3 2.4 40 8 [0.0207 0.1377 0.0000 0.0000 0.2847] [1600.0 109.0 30.0    0.0 1400.0]]
   144 [:SH4 3.0 30 8 [0.0390 0.0528 0.0092 0.0000 0.1171] [2000.0 109.0 30.0 1800.0 1600.0]]
   145 [:SH5 6.0 15 8 [0.1653 0.0964 0.0000 0.0000 0.1331] [ 750.0 109.0 30.0    0.0 1600.0]]
   146 [:SH6 2.0 30 8 [0.1331 0.0666 0.0000 0.0000 0.0643] [ 750.0 109.0 30.0    0.0 1600.0]]
   147 [:SH7 6.0 15 8 [0.1607 0.2433 0.1010 0.0000 0.1561] [ 750.0 109.0 30.0    0.0 1600.0]]
   148 [:SH8 3.0 40 8 [0.0941 0.1561 0.0390 0.0000 0.1997] [ 750.0 109.0 30.0    0.0 1600.0]]
   149 [:SH9 4.4 40 8 [0.2066 0.1125 0.0000 0.0712 0.3214] [ 750.0 109.0 30.0 1800.0 1500.0]]
   ;; Timber-Understory (TU)
   161 [:TU1 0.6 20 8 [0.0092 0.0413 0.0689 0.0092 0.0413] [2000.0 109.0 30.0 1800.0 1600.0]]
   162 [:TU2 1.0 30 8 [0.0436 0.0826 0.0574 0.0000 0.0092] [2000.0 109.0 30.0    0.0 1600.0]]
   163 [:TU3 1.3 30 8 [0.0505 0.0069 0.0115 0.0298 0.0505] [1800.0 109.0 30.0 1600.0 1400.0]]
   164 [:TU4 0.5 12 8 [0.2066 0.0000 0.0000 0.0000 0.0918] [2300.0 109.0 30.0    0.0 2000.0]]
   165 [:TU5 1.0 25 8 [0.1837 0.1837 0.1377 0.0000 0.1377] [1500.0 109.0 30.0    0.0  750.0]]
   ;; Timber Litter (TL)
   181 [:TL1 0.2 30 8 [0.0459 0.1010 0.1653 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   182 [:TL2 0.2 25 8 [0.0643 0.1056 0.1010 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   183 [:TL3 0.3 20 8 [0.0230 0.1010 0.1286 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   184 [:TL4 0.4 25 8 [0.0230 0.0689 0.1928 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   185 [:TL5 0.6 25 8 [0.0528 0.1148 0.2020 0.0000 0.0000] [2000.0 109.0 30.0    0.0 1600.0]]
   186 [:TL6 0.3 25 8 [0.1102 0.0551 0.0551 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   187 [:TL7 0.4 25 8 [0.0138 0.0643 0.3719 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   188 [:TL8 0.3 35 8 [0.2663 0.0643 0.0505 0.0000 0.0000] [1800.0 109.0 30.0    0.0    0.0]]
   189 [:TL9 0.6 35 8 [0.3053 0.1515 0.1905 0.0000 0.0000] [1800.0 109.0 30.0    0.0 1600.0]]
   ;; Slash-Blowdown (SB)
   201 [:SB1 1.0 25 8 [0.0689 0.1377 0.5051 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   202 [:SB2 1.0 25 8 [0.2066 0.1951 0.1837 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   203 [:SB3 1.2 25 8 [0.2525 0.1263 0.1377 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   204 [:SB4 2.7 25 8 [0.2410 0.1607 0.2410 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   })

(def WUI-model-number->original
  "Some variants of the above fuel models,
  with a different fuel model number to distinguish them as
  belonging to the Wildland Urban Interface (WUI).

  Each of these WUI fuel models has the same physical characteristics
  as one of the fuel models in the above table,
  but having a different model number enables a different behavior
  for other aspects, such as spread-rate adjustment or spotting.

  This table provides the mapping from variant model number -> original model number.
  Notice how the difference of model numbers is usually 100 or 110."
  {;; Grass (GR)
   211 101
   212 102
   213 103
   214 104
   215 105
   216 106
   217 107
   218 108
   ;; Grass-Shrub (GS)
   221 121
   222 122
   223 123
   224 124
   ;; Shrub (SH)
   241 141
   242 142
   243 143
   244 144
   245 145
   246 146
   247 147
   248 148
   249 149
   ;; Timber-Understory (TU)
   261 161
   262 162
   263 163
   265 165
   ;; Timber Litter (TL)
   281 181
   282 182
   283 183
   284 184
   285 185
   286 186
   287 187
   288 188
   289 189
   ;; Slash-Blowdown (SB)
   301 201
   302 202
   303 203})

(defrecord FuelModel
    [name
     ^long number
     ^double delta
     M_x
     w_o
     sigma
     h
     rho_p
     S_T
     S_e
     M_f
     f_ij
     f_i
     g_ij])

(defn is-dynamic-fuel-model-number?
  [^long fuel-model-number]
  (> fuel-model-number 100))

(defn compute-fuel-model
  [^long fuel-model-number]
  (let [[name delta M_x-dead h
         [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr
          w_o-live-herbaceous w_o-live-woody]
         [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr
          sigma-live-herbaceous sigma-live-woody]]
        (fuel-models fuel-model-number)
        M_x-dead   (* ^long M_x-dead 0.01)
        h          (* ^long h 1000.0)
        fuel-model {:name   name
                    :number fuel-model-number
                    :delta  delta
                    :M_x    [M_x-dead M_x-dead M_x-dead 0.0 0.0 0.0]
                    :w_o    [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr 0.0 w_o-live-herbaceous w_o-live-woody]
                    :sigma  [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr 0.0 sigma-live-herbaceous sigma-live-woody]
                    :h      [h h h h h h]
                    :rho_p  [32.0 32.0 32.0 32.0 32.0 32.0]
                    :S_T    [0.0555 0.0555 0.0555 0.0555 0.0555 0.0555]
                    :S_e    [0.01 0.01 0.01 0.01 0.01 0.01]}]
    (if (and (is-dynamic-fuel-model-number? fuel-model-number)
             (pos? ^double w_o-live-herbaceous))
      ;; Set dead-herbaceous values
      (-> fuel-model
          (assoc-in [:M_x   3] M_x-dead)
          (assoc-in [:sigma 3] sigma-live-herbaceous))
      ;; No dead-herbaceous values
      fuel-model)))

(defn- add-synonym-models
  [variant->original-model-number number->model-data]
  (reduce-kv (fn [ret v-num o-num]
               (assoc ret v-num (or (get number->model-data o-num)
                                    (throw (ex-info (format "Cannot find synonym fuel model number: %s" (pr-str o-num))
                                                    {::variant-fuel-model-number  v-num
                                                     ::original-fuel-model-number o-num})))))
             number->model-data
             variant->original-model-number))

(def fuel-models-precomputed (->> fuel-models
                                  (keys)
                                  (into {} (map #(vector % (map->FuelModel (compute-fuel-model %)))))
                                  (add-synonym-models WUI-model-number->original)))
#+end_src

Once fuel moisture is added to the base fuel model definitions, they
will each contain values for the following six fuel size classes:

#+ATTR_LATEX: :options \setlength{\itemsep}{-3mm}
1. Dead 1 hour ($<$ 1/4" diameter)
2. Dead 10 hour (1/4"--1" diameter)
3. Dead 100 hour (1"--3" diameter)
4. Dead herbaceous (dynamic fuel models only)
5. Live herbaceous
6. Live woody

In order to more easily encode mathematical operations over these size
classes, we define a collection of utility functions that will later
be used in both the fuel moisture and fire spread algorithms.

#+name: fuel-category-and-size-class-functions
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn map-category [f]
  {:dead (f :dead) :live (f :live)})

(defn map-size-class [f]
  {:dead {:1hr        (f :dead :1hr)
          :10hr       (f :dead :10hr)
          :100hr      (f :dead :100hr)
          :herbaceous (f :dead :herbaceous)}
   :live {:herbaceous (f :live :herbaceous)
          :woody      (f :live :woody)}})

(defn category-sum ^double [f]
  (+ ^double (f :dead) ^double (f :live)))

(defn size-class-sum [f]
  {:dead (+ ^double (f :dead :1hr) ^double (f :dead :10hr) ^double (f :dead :100hr) ^double (f :dead :herbaceous))
   :live (+ ^double (f :live :herbaceous) ^double (f :live :woody))})
#+end_src

Using these new size class processing functions, we can translate the
encoded fuel model definitions into human-readable representations of
the fuel model properties.

#+name: fuel-model-constructor-functions
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn build-fuel-model
  [fuel-model-number]
  (let [[name delta ^double M_x-dead ^double h
         [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr
          w_o-live-herbaceous w_o-live-woody]
         [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr
          sigma-live-herbaceous sigma-live-woody]]
        (fuel-models fuel-model-number)
        M_x-dead (* M_x-dead 0.01)
        h        (* h 1000.0)]
    {:name   name
     :number fuel-model-number
     :delta  delta
     :M_x    {:dead {:1hr        M_x-dead
                     :10hr       M_x-dead
                     :100hr      M_x-dead
                     :herbaceous 0.0}
              :live {:herbaceous 0.0
                     :woody      0.0}}
     :w_o    {:dead {:1hr        w_o-dead-1hr
                     :10hr       w_o-dead-10hr
                     :100hr      w_o-dead-100hr
                     :herbaceous 0.0}
              :live {:herbaceous w_o-live-herbaceous
                     :woody      w_o-live-woody}}
     :sigma  {:dead {:1hr        sigma-dead-1hr
                     :10hr       sigma-dead-10hr
                     :100hr      sigma-dead-100hr
                     :herbaceous 0.0}
              :live {:herbaceous sigma-live-herbaceous
                     :woody      sigma-live-woody}}
     :h      {:dead {:1hr        h
                     :10hr       h
                     :100hr      h
                     :herbaceous h}
              :live {:herbaceous h
                     :woody      h}}
     :rho_p  {:dead {:1hr        32.0
                     :10hr       32.0
                     :100hr      32.0
                     :herbaceous 32.0}
              :live {:herbaceous 32.0
                     :woody      32.0}}
     :S_T    {:dead {:1hr        0.0555
                     :10hr       0.0555
                     :100hr      0.0555
                     :herbaceous 0.0555}
              :live {:herbaceous 0.0555
                     :woody      0.0555}}
     :S_e    {:dead {:1hr        0.01
                     :10hr       0.01
                     :100hr      0.01
                     :herbaceous 0.01}
              :live {:herbaceous 0.01
                     :woody      0.01}}}))
#+end_src

Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:

#+ATTR_LATEX: :options \setlength{\itemsep}{-3mm}
1. Dynamic fuel loading
2. Live moisture of extinction

These two topics are discussed in the remainder of this section.

*** Dynamic Fuel Loading

All of the Scott & Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).\citep{Burgan1979} The dead herbaceous category uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
$M_{f}^{lh}$ is the live herbaceous moisture content.

\begin{align*}
  \textrm{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_{f}^{lh} \le 0.3 \\
      1 & M_{f}^{lh} \ge 1.2 \\
      \frac{M_{f}^{lh}}{0.9} - \frac{1}{3} & \textrm{else}
    \end{array}
  \right. \\
  \textrm{FractionCured} &= 1 - \textrm{FractionGreen}
\end{align*}

#+name: add-dynamic-fuel-loading
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn add-dynamic-fuel-loading
  [{:keys [number M_x M_f w_o sigma] :as fuel-model}]
  (let [number               (double number)
        live-herbaceous-load (-> w_o :live :herbaceous double)]
    (if (and (> number 100) (pos? live-herbaceous-load))
      ;; dynamic fuel model
      (let [fraction-green (max 0.0 (min 1.0 (- (/ (-> M_f :live :herbaceous double) 0.9) (/ 1.0 3.0))))
            fraction-cured (- 1.0 fraction-green)]
        (-> fuel-model
            (assoc-in [:M_f   :dead :herbaceous] (-> M_f :dead :1hr))
            (assoc-in [:M_x   :dead :herbaceous] (-> M_x :dead :1hr))
            (assoc-in [:w_o   :dead :herbaceous] (* live-herbaceous-load fraction-cured))
            (assoc-in [:w_o   :live :herbaceous] (* live-herbaceous-load fraction-green))
            (assoc-in [:sigma :dead :herbaceous] (-> sigma :live :herbaceous))))
      ;; static fuel model
      fuel-model)))
#+end_src

Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972\citep{Rothermel1972}. For brevity, these formulas are elided from
this text.

#+name: add-weighting-factors
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn add-weighting-factors
  [{:keys [w_o sigma rho_p] :as fuel-model}]
  (let [A_ij (map-size-class (fn [i j] (/ (* (-> sigma i ^double (j)) (-> w_o i ^double (j)))
                                          (-> rho_p i ^double (j)))))

        A_i  (size-class-sum (fn [i j] (-> A_ij i j)))

        A_T  (category-sum (fn [i] (-> A_i i)))

        f_ij (map-size-class (fn [i j] (if (pos? ^double ( A_i i))
                                         (/ (-> A_ij i ^double (j))
                                            ^double (A_i i))
                                         0.0)))

        f_i  (map-category (fn [i] (if (pos? A_T)
                                     (/ ^double (A_i i) A_T)
                                     0.0)))

        firemod-size-classes (map-size-class
                              (fn [i j] (condp <= (-> sigma i j)
                                          1200 1
                                          192  2
                                          96   3
                                          48   4
                                          16   5
                                          0    6)))

        firemod-weights (into {}
                              (for [[category size-classes] firemod-size-classes]
                                [category
                                 (apply merge-with +
                                        (for [[size-class firemod-size-class] size-classes]
                                          {firemod-size-class (get-in f_ij [category size-class])}))]))

        g_ij (map-size-class (fn [i j]
                               (let [firemod-size-class (-> firemod-size-classes i j)]
                                 (get-in firemod-weights [i firemod-size-class]))))]
    (-> fuel-model
        (assoc :f_ij f_ij)
        (assoc :f_i  f_i)
        (assoc :g_ij g_ij))))
#+end_src

*** Live Moisture of Extinction

The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.\citep{Rothermel1972,Albini1976} Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:

\begin{align*}
  M_{x}^{l} &= \max(M_{x}^{d}, 2.9 \, W' \, (1 - \frac{M_{f}^{d}}{M_{x}^{d}}) - 0.226) \\
  W' &= \frac{\sum_{c \in D}{w_{o}^{c} \> e^{-138/\sigma^{c}}}}{\sum_{c \in L}{w_{o}^{c} \> e^{-500/\sigma^{c}}}} \\
  M_{f}^{d} &= \frac{\sum_{c \in D}{w_{o}^{c} \> M_{f}^{c} \> e^{-138/\sigma^{c}}}}{\sum_{c \in D}{w_{o}^{c} \> e^{-138/\sigma^{c}}}}
\end{align*}

where $M_{x}^{l}$ is the live moisture of extinction, $M_{x}^{d}$ is
the dead moisture of extinction, $D$ is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), $L$ is the set of live fuel
size classes (herbaceous, woody), $w_{o}^{c}$ is the dry weight
loading of size class $c$, $\sigma^{c}$ is the surface area to volume
ratio of size class $c$, and $M_{f}^{c}$ is the moisture content of
size class $c$.

#+name: add-live-moisture-of-extinction
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn add-live-moisture-of-extinction
  "Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III."
  [{:keys [w_o sigma M_f M_x] :as fuel-model}]
  (let [dead-loading-factor  (->> (size-class-sum
                                   (fn [i j] (let [sigma_ij (-> sigma i j double)]
                                               (if (pos? sigma_ij)
                                                 (* (-> w_o i ^double (j))
                                                    (Math/exp (/ -138.0 sigma_ij)))
                                                 0.0))))
                                  :dead
                                  double)
        live-loading-factor  (->> (size-class-sum
                                   (fn [i j] (let [sigma_ij (-> sigma i j double)]
                                               (if (pos? sigma_ij)
                                                 (* (-> w_o i ^double (j))
                                                    (Math/exp (/ -500.0 sigma_ij)))
                                                 0.0))))
                                  :live
                                  double)
        dead-moisture-factor (->> (size-class-sum
                                   (fn [i j] (let [sigma_ij (-> sigma i j double)]
                                              (if (pos? sigma_ij)
                                                (* (-> w_o i ^double (j))
                                                   (Math/exp (/ -138.0 sigma_ij))
                                                   (-> M_f i ^double (j)))
                                                0.0))))
                                  :dead
                                  double)
        ^double
        dead-to-live-ratio   (when (pos? live-loading-factor)
                               (/ dead-loading-factor live-loading-factor))
        dead-fuel-moisture   (if (pos? dead-loading-factor)
                               (/ dead-moisture-factor dead-loading-factor)
                               0.0)
        M_x-dead             (-> M_x :dead :1hr double)
        M_x-live             (if (pos? live-loading-factor)
                               (max M_x-dead
                                    (- (* 2.9
                                          dead-to-live-ratio
                                          (- 1.0 (/ dead-fuel-moisture M_x-dead)))
                                       0.226))
                               M_x-dead)]
    (-> fuel-model
        (assoc-in [:M_x :live :herbaceous] M_x-live)
        (assoc-in [:M_x :live :woody]      M_x-live))))

(defn moisturize
  [fuel-model fuel-moisture]
  (-> fuel-model
      (assoc :M_f fuel-moisture)
      (assoc-in [:M_f :dead :herbaceous] 0.0)
      (add-dynamic-fuel-loading)
      (add-weighting-factors)
      (add-live-moisture-of-extinction)))
#+end_src

This concludes our coverage of fuel models and and fuel moisture.

** Surface Fire Formulas

To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), we adopt the surface fire spread and reaction intensity
formulas from Rothermel's 1972 publication ``A Mathematical Model for
Predicting Fire Spread in Wildland Fuels''.\citep{Rothermel1972}

Very briefly, the surface rate of spread of a fire's leading edge $R$
is described by the following formula:

\begin{displaymath}
R = \frac{I_{R} \, \xi \, (1 + \phi_{W} + \phi_{S})}{\rho_{b} \, \epsilon \, Q_{ig}}
\end{displaymath}

where these terms have the meanings shown in Table
[[tab:fire-spread-inputs]].

#+NAME: tab:fire-spread-inputs
#+CAPTION: Inputs to Rothermel's surface fire rate of spread equation
#+ATTR_LATEX: :align |l|l| :font \small
|----------+--------------------------------|
| Term     | Meaning                        |
|----------+--------------------------------|
| R        | surface fire spread rate       |
| I_{R}    | reaction intensity             |
| \xi      | propagating flux ratio         |
| \phi_{W} | wind coefficient               |
| \phi_{S} | slope factor                   |
| \rho_{b} | oven-dry fuel bed bulk density |
| \epsilon | effective heating number       |
| Q_{ig}   | heat of preignition            |
|----------+--------------------------------|

For a full description of each of the subcomponents of Rothermel's
surface fire spread rate equation, see the Rothermel 1972 reference
above. In addition to applying the base Rothermel equations, GridFire
can reduce the spread rates for all of the Scott & Burgan 40 fuel models
of the grass subgroup (101-109) by 50% by enabling the ~:grass-suppression?~
configuration. This addition was originally suggested by Chris Lautenberger
of REAX Engineering.

For efficiency, the surface fire spread equation given above is
computed first without introducing the effects of wind and slope
($\phi_{W} = \phi_{S} = 0$).

#+name: rothermel-surface-fire-spread-no-wind-no-slope
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :padline no :no-expand :comments link
(ns gridfire.surface-fire
  (:require [gridfire.fuel-models :refer [map-category map-size-class
                                          category-sum size-class-sum]]))

(defn grass-fuel-model?
  [^long number]
  (and (> number 100) (< number 110)))

(defn rothermel-surface-fire-spread-no-wind-no-slope
  "Returns the rate of surface fire spread in ft/min and the reaction
   intensity (i.e., amount of heat output) of a fire in Btu/ft^2*min
   given a map containing these keys:
   - number [fuel model number]
   - delta [fuel depth (ft)]
   - w_o [ovendry fuel loading (lb/ft^2)]
   - sigma [fuel particle surface-area-to-volume ratio (ft^2/ft^3)]
   - h [fuel particle low heat content (Btu/lb)]
   - rho_p [ovendry particle density (lb/ft^3)]
   - S_T [fuel particle total mineral content (lb minerals/lb ovendry wood)]
   - S_e [fuel particle effective mineral content (lb silica-free minerals/lb ovendry wood)]
   - M_x [moisture content of extinction (lb moisture/lb ovendry wood)]
   - M_f [fuel particle moisture content (lb moisture/lb ovendry wood)]
   - f_ij [percent of load per size class (%)]
   - f_i [percent of load per category (%)]
   - g_ij [percent of load per size class from Albini_1976_FIREMOD, page 20]"
  [{:keys [number delta w_o sigma  h rho_p S_T S_e M_x  M_f f_ij f_i g_ij]} & [grass-suppression?]]
  (let [number     (long number)
        delta      (double delta)
        S_e_i      (size-class-sum (fn [i j] (* (-> f_ij i ^double (j)) (-> S_e i ^double (j)))))

        ;; Mineral damping coefficient
        eta_S_i    (map-category (fn [i] (let [^double S_e_i (-> S_e_i i)]
                                           (if (pos? S_e_i)
                                             (/ 0.174 (Math/pow S_e_i 0.19))
                                             1.0))))

        M_f_i      (size-class-sum (fn [i j] (* (-> f_ij i ^double (j)) (-> M_f i ^double (j)))))

        M_x_i      (size-class-sum (fn [i j] (* (-> f_ij i ^double (j)) (-> M_x i ^double (j)))))

        r_M_i      (map-category (fn [i] (let [^double M_f (-> M_f_i i)
                                               ^double M_x (-> M_x_i i)]
                                           (if (pos? M_x)
                                             (min 1.0 (/ M_f M_x))
                                             1.0))))

        ;; Moisture damping coefficient
        eta_M_i    (map-category (fn [i] (+ 1.0
                                            (* -2.59 (-> r_M_i ^double (i)))
                                            (* 5.11 (Math/pow (-> r_M_i i) 2))
                                            (* -3.52 (Math/pow (-> r_M_i i) 3)))))

        h_i        (size-class-sum (fn [i j] (* (-> f_ij i ^double (j)) (-> h i ^double (j)))))

        ;; Net fuel loading (lb/ft^2)
        W_n_i      (size-class-sum (fn [i j] (* (-> g_ij i ^double (j))
                                                (-> w_o i ^double (j))
                                                (- 1.0 (-> S_T i ^double (j))))))

        beta_i     (size-class-sum (fn [i j] (/ (-> w_o i ^double (j)) (-> rho_p i ^double (j)))))

        ;; Packing ratio
        beta       (if (pos? delta)
                     (/ (category-sum (fn [i] (-> beta_i ^double (i)))) delta)
                     0.0)

        sigma'_i   (size-class-sum (fn [i j] (* (-> f_ij i ^double (j)) (-> sigma i ^double (j)))))

        sigma'     (category-sum (fn [i] (* (-> f_i ^double (i)) (-> sigma'_i ^double (i)))))

        ;; Optimum packing ratio
        beta_op    (if (pos? sigma')
                     (/ 3.348 (Math/pow sigma' 0.8189))
                     1.0)

        ;; Albini 1976 replaces (/ 1 (- (* 4.774 (Math/pow sigma' 0.1)) 7.27))
        A          (if (pos? sigma')
                     (/ 133.0 (Math/pow sigma' 0.7913))
                     0.0)

        ;; Maximum reaction velocity (1/min)
        Gamma'_max (/ (Math/pow sigma' 1.5)
                      (+ 495.0 (* 0.0594 (Math/pow sigma' 1.5))))

        ;; Optimum reaction velocity (1/min)
        Gamma'     (* Gamma'_max
                      (Math/pow (/ beta beta_op) A)
                      (Math/exp (* A (- 1.0 (/ beta beta_op)))))

        ;; Reaction intensity (Btu/ft^2*min)
        I_R        (* Gamma' (category-sum (fn [i] (* ^double (W_n_i i) ^double (h_i i)
                                                      ^double (eta_M_i i) ^double (eta_S_i i)))))

        ;; Propagating flux ratio
        xi         (/ (Math/exp (* (+ 0.792 (* 0.681 (Math/pow sigma' 0.5)))
                                   (+ beta 0.1)))
                      (+ 192.0 (* 0.2595 sigma')))

        E          (* 0.715 (Math/exp (* -3.59 (/ sigma' 10000.0))))

        B          (* 0.02526 (Math/pow sigma' 0.54))

        C          (* 7.47 (Math/exp (* -0.133 (Math/pow sigma' 0.55))))

        ;; Derive wind factor
        get-phi_W  (fn ^double [^double midflame-wind-speed]
                     (if (and (pos? beta) (pos? midflame-wind-speed))
                       (-> midflame-wind-speed
                           (Math/pow B)
                           (* C)
                           (/ (Math/pow (/ beta beta_op) E)))
                       0.0))

        ;; Derive wind speed from wind factor
        get-wind-speed (fn [^double phi_W]
                         (-> phi_W
                             (* (Math/pow (/ beta beta_op) E))
                             ^double (/ C)
                             (Math/pow (/ 1.0 B))))

        ;; Derive slope factor
        get-phi_S  (fn [^double slope]
                     (if (and (pos? beta) (pos? slope))
                       (* 5.275 (Math/pow beta -0.3) (Math/pow slope 2.0))
                       0.0))

        ;; Heat of preignition (Btu/lb)
        Q_ig       (map-size-class (fn [i j] (+ 250.0 (* 1116.0 (-> M_f i ^double (j))))))

        foo_i      (size-class-sum (fn [i j] (let [^double sigma_ij (-> sigma i j)
                                                   ^double Q_ig_ij  (-> Q_ig  i j)]
                                               (if (pos? sigma_ij)
                                                 (* (-> f_ij i ^double (j))
                                                    (Math/exp (/ -138 sigma_ij))
                                                    Q_ig_ij)
                                                 0.0))))

        rho_b_i    (size-class-sum (fn [i j] (-> w_o i j)))

        ;; Ovendry bulk density (lb/ft^3)
        rho_b      (if (pos? delta)
                     (/ (category-sum (fn [i] (-> rho_b_i i))) delta)
                     0.0)

        rho_b-epsilon-Q_ig (* rho_b (category-sum (fn [i] (* (-> f_i ^double (i)) (-> foo_i ^double (i))))))

        ;; Surface fire spread rate (ft/min)
        R          (if (pos? rho_b-epsilon-Q_ig)
                     (/ (* I_R xi) rho_b-epsilon-Q_ig)
                     0.0)

        ;; Addition proposed by Chris Lautenberger (REAX 2015)
        spread-rate-multiplier (if (and grass-suppression? (grass-fuel-model? number)) 0.5 1.0)]

    {:spread-rate        (* R spread-rate-multiplier)
     :reaction-intensity I_R
     :residence-time     (/ 384.0 sigma')
     :get-phi_W          get-phi_W
     :get-phi_S          get-phi_S
     :get-wind-speed     get-wind-speed}))
#+end_src

Later, this no-wind-no-slope value is used to compute the maximum
spread rate and direction for the leading edge of the surface fire
under analysis. Since Rothermel's original equations assume that the
wind direction and slope are aligned, the effects of cross-slope winds
must be taken into effect. Like Morais' HFire system, GridFire implements
the vector addition procedure defined in Rothermel 1983 that combines
the wind-only and slope-only spread rates independently to calculate
the effective fire spread direction and
magnitude.\citep{Peterson2011,Peterson2009,Morais2001,Rothermel1983}

A minor wrinkle is introduced when putting these calculations into
practice because Rothermel's formulas all expect a measure of midflame
wind speed. However, wind speed data is often collected at a height 20
feet above either unsheltered ground or a tree canopy layer if
present. To convert this 20-ft wind speed to the required midflame
wind speed value, GridFire uses the *wind adjustment factor* formula
from Albini & Baughman 1979, parameterized as in BehavePlus, FARSITE,
FlamMap, FSPro, and FPA according to Andrews
2012\citep{Albini1979,Andrews2012}. This formula is shown below:

\begin{displaymath}
  WAF = \left\{
    \begin{array}{lr}
      \frac{1.83}{ \ln(\frac{20.0 + 0.36 FBD}{0.13 FBD}) } & CC = 0 \\
      \frac{0.555}{ \sqrt(CH (CC/300.0)) \ln(\frac{20 + 0.36 CH}{0.13 CH}) } & CC > 0
    \end{array}
  \right.
\end{displaymath}

where WAF is the unitless wind adjustment factor, FBD is the fuel bed
depth in feet, CH is the canopy height in ft, and CC is the canopy
cover percentage (0-100).

#+name: wind-adjustment-factor
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :no-expand :comments link
(defn wind-adjustment-factor
  "ft ft 0-100"
  ^double
  [^double fuel-bed-depth ^double canopy-height ^double canopy-cover]
  (cond
    ;; sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)
    (and (pos? canopy-cover)
         (pos? canopy-height))
    (/ 0.555 (* (Math/sqrt (* (/ canopy-cover 300.0) canopy-height))
                (Math/log (/ (+ 20.0 (* 0.36 canopy-height)) (* 0.13 canopy-height)))))

    ;; unsheltered: equation 6 H_F = H (Andrews 2012)
    (pos? fuel-bed-depth)
    (/ 1.83 (Math/log (/ (+ 20.0 (* 0.36 fuel-bed-depth)) (* 0.13 fuel-bed-depth))))

    ;; non-burnable fuel model
    :otherwise
    0.0))

(defn wind-adjustment-factor-elmfire
  "ft m 0-1"
  ^double
  [^double fuel-bed-depth ^double canopy-height ^double canopy-cover]
  (cond
    ;; sheltered WAF
    (and (pos? canopy-cover)
         (pos? canopy-height))
    (* (/ 1.0 (Math/log (/ (+ 20.0 (* 0.36 (/ canopy-height 0.3048)))
                           (* 0.13 (/ canopy-height 0.3048)))))
       (/ 0.555 (Math/sqrt (* (/ canopy-cover 3.0) (/ canopy-height 0.3048)))))

    ;; unsheltered WAF
    (pos? fuel-bed-depth)
    (* (/ (+ 1.0 (/ 0.36 1.0))
          (Math/log (/ (+ 20.0 (* 0.36 fuel-bed-depth))
                       (* 0.13 fuel-bed-depth))))
       (- (Math/log (/ (+ 1.0 0.36) 0.13)) 1.0))

    ;; non-burnable fuel model
    :otherwise
    0.0))
#+end_src

The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
$U_{\textrm{eff}}$. Following the recommendations given in Appendix
III of Albini 1976, these midflame wind speeds are all limited to $0.9
I_{R}$.\citep{Albini1976}

Next, the effective wind speed is used to compute the length to width
ratio $\frac{L}{W}$ of an ellipse that approximates the fire front
using equation 9 from Rothermel 1991.\citep{Rothermel1991} This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.\citep{Albini1980}
Finally, this eccentricity $E$ is used to project the maximum spread
rate to any point along the fire front. Here are the formulas used:

\begin{align*}
  \frac{L}{W} &= 1 + 0.002840909 \, U_{\textrm{eff}} \, \textrm{EAF} \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align*}

where \theta is the angular offset from the direction of maximum fire
spread, R_{max} is the maximum spread rate, R_{\theta} is the spread
rate in direction \theta, and EAF is the ellipse adjustment factor, a
term introduced by Marco Morais and Seth Peterson in their HFire work
that can be increased or decreased to make the fire shape more
elliptical or circular respectively.\citep{Peterson2009}

*Note:* The coefficient 0.002840909 in the $\frac{L}{W}$ formula is in
units of min/ft. The original equation from Rothermel 1991 used 0.25
in units of hr/mi, so this was converted to match GridFire's use of
ft/min for $U_{\textrm{eff}}$.

#+name: rothermel-surface-fire-spread-max-and-any
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :no-expand :comments link
(defn almost-zero? [^double x]
  (< (Math/abs x) 0.000001))

(defn degrees-to-radians ^double
  [^double degrees]
  (/ (* degrees Math/PI) 180.0))

(defn radians-to-degrees
  ^double
  [^double radians]
  (/ (* radians 180.0) Math/PI))

(defn scale-spread-to-max-wind-speed
  [{:keys [effective-wind-speed max-spread-direction] :as spread-properties}
   ^double spread-rate max-wind-speed  ^double phi-max]
  (let [effective-wind-speed (double effective-wind-speed)
        max-spread-direction (double max-spread-direction)]
    (if (> effective-wind-speed ^double max-wind-speed)
      {:max-spread-rate      (* spread-rate (+ 1.0 phi-max))
       :max-spread-direction max-spread-direction
       :effective-wind-speed max-wind-speed}
      spread-properties)))

(defn add-eccentricity
  [{:keys [effective-wind-speed] :as spread-properties} ellipse-adjustment-factor]
  (let [effective-wind-speed (double effective-wind-speed)
        length-width-ratio (+ 1.0 (* 0.002840909
                                     effective-wind-speed
                                     ^double ellipse-adjustment-factor))
        eccentricity       (/ (Math/sqrt (- (Math/pow length-width-ratio 2.0) 1.0))
                              length-width-ratio)]
    (assoc spread-properties :eccentricity eccentricity)))

(defn smallest-angle-between ^double
  [^double theta1 ^double theta2]
  (let [angle (Math/abs (- theta1 theta2))]
    (if (> angle 180.0)
      (- 360.0 angle)
      angle)))

(defn rothermel-surface-fire-spread-max
  "Note: fire ellipse adjustment factor, < 1.0 = more circular, > 1.0 = more elliptical"
  [{:keys [spread-rate reaction-intensity get-phi_W get-phi_S get-wind-speed]}
   midflame-wind-speed wind-from-direction slope aspect ellipse-adjustment-factor]
  (let [^double phi_W             (get-phi_W midflame-wind-speed)
        ^double phi_S             (get-phi_S slope)
        ^double slope-direction   (mod (+ ^double aspect 180.0) 360.0)
        ^double wind-to-direction (mod (+ ^double wind-from-direction 180.0) 360.0)
        max-wind-speed            (* 0.9 ^double reaction-intensity)
        ^double phi-max           (get-phi_W max-wind-speed)
        spread-rate               (double spread-rate)]
    (->
     (cond (and (almost-zero? midflame-wind-speed) (almost-zero? slope))
           ;; no wind, no slope
           {:max-spread-rate      spread-rate
            :max-spread-direction 0.0
            :effective-wind-speed 0.0}

           (almost-zero? slope)
           ;; wind only
           {:max-spread-rate      (* spread-rate (+ 1.0 phi_W))
            :max-spread-direction wind-to-direction
            :effective-wind-speed midflame-wind-speed}

           (almost-zero? midflame-wind-speed)
           ;; slope only
           {:max-spread-rate      (* spread-rate (+ 1.0 phi_S))
            :max-spread-direction slope-direction
            :effective-wind-speed (get-wind-speed phi_S)}

           (< (smallest-angle-between wind-to-direction slope-direction) 15.0)
           ;; wind blows (within 15 degrees of) upslope
           {:max-spread-rate      (* spread-rate (+ 1.0 phi_W phi_S))
            :max-spread-direction slope-direction
            :effective-wind-speed (get-wind-speed (+ phi_W phi_S))}

           :else
           ;; wind blows across slope
           (let [slope-magnitude    (* spread-rate phi_S)
                 wind-magnitude     (* spread-rate phi_W)
                 difference-angle   (degrees-to-radians
                                     (mod (- wind-to-direction slope-direction) 360.0))
                 x                  (+ slope-magnitude
                                       (* wind-magnitude (Math/cos difference-angle)))
                 y                  (* wind-magnitude (Math/sin difference-angle))
                 combined-magnitude (Math/sqrt (+ (* x x) (* y y)))]
             (if (almost-zero? combined-magnitude)
               {:max-spread-rate      spread-rate
                :max-spread-direction 0.0
                :effective-wind-speed 0.0}
               (let [max-spread-rate      (+ spread-rate combined-magnitude)
                     phi-combined         (- (/ max-spread-rate spread-rate) 1.0)
                     offset               (radians-to-degrees
                                           (Math/asin (/ (Math/abs y) combined-magnitude)))
                     offset'              (if (>= x 0.0)
                                            (if (>= y 0.0)
                                              offset
                                              (- 360.0 offset))
                                            (if (>= y 0.0)
                                              (- 180.0 offset)
                                              (+ 180.0 offset)))
                     max-spread-direction (mod (+ slope-direction offset') 360.0)
                     effective-wind-speed (get-wind-speed phi-combined)]
                 {:max-spread-rate      max-spread-rate
                  :max-spread-direction max-spread-direction
                  :effective-wind-speed effective-wind-speed}))))
     (scale-spread-to-max-wind-speed spread-rate max-wind-speed phi-max)
     (add-eccentricity ellipse-adjustment-factor))))

(defn rothermel-surface-fire-spread-any ^double
  [{:keys [max-spread-rate max-spread-direction eccentricity]} spread-direction]
  (let [max-spread-rate      (double max-spread-rate)
        max-spread-direction (double max-spread-direction)
        eccentricity         (double eccentricity)
        theta                (smallest-angle-between max-spread-direction spread-direction)]
    (if (or (almost-zero? eccentricity) (almost-zero? theta))
      max-spread-rate
      (* max-spread-rate (/ (- 1.0 eccentricity)
                            (- 1.0 (* eccentricity
                                      (Math/cos (degrees-to-radians theta)))))))))
#+end_src

Using these surface fire spread rate and reaction intensity values, we
next calculate fire intensity values by applying Anderson's flame
depth formula and Byram's fire line intensity and flame length
equations as described below.\citep{Anderson1969,Byram1959}

\begin{align*}
  t &= \frac{384}{\sigma} \\
  D &= Rt \\
  I &= \frac{I_{R}D}{60} \\
  L &= 0.45(I)^{0.46}
\end{align*}

where $\sigma$ is the weighted sum by size class of the fuel model's
surface area to volume ratio in ft^{2}/ft^{3}, $t$ is the residence
time in minutes, $R$ is the surface fire spread rate in ft/min, $D$ is
the flame depth in ft, $I_{R}$ is the reaction intensity in
Btu/ft^{2}/min, $I$ is the fire line intensity in Btu/ft/s, and $L$ is
the flame length in ft.

#+name: surface-fire-intensity-formulas
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :no-expand :comments link
(defn anderson-flame-depth
  "Returns the depth, or front-to-back distance, of the actively flaming zone
   of a free-spreading fire in ft given:
   - spread-rate (ft/min)
   - residence-time (min)"
  ^double
  [^double spread-rate ^double residence-time]
  (* spread-rate residence-time))

(defn byram-fire-line-intensity
  "Returns the rate of heat release per unit of fire edge in Btu/ft*s given:
   - reaction-intensity (Btu/ft^2*min)
   - flame-depth (ft)"
  ^double
  [^double reaction-intensity ^double flame-depth]
  (/ (* reaction-intensity flame-depth) 60.0))

(defn byram-flame-length
  "Returns the average flame length in ft given:
   - fire-line-intensity (Btu/ft*s)"
  ^double
  [^double fire-line-intensity]
  (* 0.45 (Math/pow fire-line-intensity 0.46)))
#+end_src

This concludes our coverage of the surface fire behavior equations
implemented in GridFire. In Section [[Fire Spread on a Raster Grid]],
these formulas will be translated from one-dimension to
two-dimensional spread on a raster grid. Before we move on to that,
however, the following section explains how crown fire behavior
metrics are incorporated into our model.

** Crown Fire Formulas

In order to incorporate the effects of crown fire behavior, GridFire
includes the crown fire initiation routine from Van Wagner
1977.\citep{VanWagner1977} According to this approach, there are two
threshold values (/critical intensity/ and /critical spread rate/)
that must be calculated in order to determine whether a fire will
become an active or passive crown fire or simply remain a surface
fire. The formulas for these thresholds are as follows:

\begin{align*}
  H &= 460 + 2600 M^{f} \\
  I^{*} &= (0.01 \, Z_{b} \, H)^{1.5} \\
  R^{*} &= \frac{3.0}{B_{m}}
\end{align*}

where $H$ is the heat of ignition for the herbaceous material in the
canopy in kJ/kg, $M^{f}$ is the foliar moisture content in lb
moisture/lb ovendry weight, $Z_{b}$ is the canopy base height in
meters, $I^{*}$ is the critical intensity in kW/m, $B_{m}$ is the
crown bulk density in kg/m^{3}, and $R^{*}$ is the critical spread
rate in m/min.

If the canopy cover is greater than 40% and the surface fire line
intensity is greater than the critical intensity ($I > I^{*}$), then
crown fire initiation occurs.

#+name: van-wagner-crown-fire-initiation
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :padline no :no-expand :comments link
(ns gridfire.crown-fire
  (:require [gridfire.conversion :as convert]))

(set! *unchecked-math* :warn-on-boxed)

(defn van-wagner-critical-fire-line-intensity
  "Ouputs the critical fire line intensity (kW/m) using:
   - canopy-base-height (m)
   - foliar-moisture (0-100 %)"
  ^double
  [^double canopy-base-height ^double foliar-moisture]
  (-> foliar-moisture
      (* 26.0)
      (+ 460.0) ;; heat-of-ignition = kJ/kg
      (* 0.01)  ;; empirical estimate for C in eq. 4
      (* canopy-base-height)
      (Math/pow 1.5))) ;; critical-intensity = kW/m

(defn van-wagner-crown-fire-initiation-metric?
  "- canopy-cover (0-100 %)
   - canopy-base-height (m)
   - foliar-moisture (0-100 %)
   - fire-line-intensity (kW/m)"
  [^double canopy-cover ^double canopy-base-height ^double foliar-moisture ^double fire-line-intensity]
  (and (> canopy-cover 40.0)
       (> fire-line-intensity 0.0)
       (> canopy-base-height 0.0)
       (>= fire-line-intensity (van-wagner-critical-fire-line-intensity canopy-base-height foliar-moisture))))

(defn van-wagner-crown-fire-initiation?
  "- canopy-cover (0-100 %)
   - canopy-base-height (ft)
   - foliar-moisture (0-1)
   - fire-line-intensity (Btu/ft*s)"
  [^double canopy-cover ^double canopy-base-height ^double foliar-moisture ^double fire-line-intensity]
  (van-wagner-crown-fire-initiation-metric? canopy-cover
                                            (convert/ft->m canopy-base-height)
                                            (convert/dec->percent foliar-moisture)
                                            (convert/Btu-ft-s->kW-m fire-line-intensity)))
#+end_src

If crowning occurs, then the active and passive crown fire spread
rates are calculated from the formulas given in Cruz
2005.\citep{Cruz2005}

\begin{align*}
  \textrm{CROS}_{A} &= 11.02 \> U_{10m}^{0.90} \> B_{m}^{0.19} \> e^{-0.17 \, \textrm{EFFM}} \\
  \textrm{CROS}_{P} &= \textrm{CROS}_{A} \> e^{\frac{-\textrm{CROS}_{A}}{R^{*}}}
\end{align*}

where $\textrm{CROS}_{A}$ is the active crown fire spread rate in
m/min, $U_{10m}$ is the 10 meter windspeed in km/hr, $B_{m}$ is the
crown bulk density in kg/m^{3}, EFFM is the estimated fine fuel
moisture as a percent (0-100), and $\textrm{CROS}_{P}$ is the passive
crown fire spread rate in m/min.

If the active crown fire spread rate is greater than the critical
spread rate ($\textrm{CROS}_{A} > R^{*}$), then the crown fire will be
active, otherwise passive.

#+name: cruz-crown-fire-spread
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :no-expand :comments link
(defn cruz-active-crown-fire-spread
  "Returns active spread-rate in m/min given:
   - wind-speed-10m (km/hr)
   - crown-bulk-density (kg/m^3)
   - estimated-fine-fuel-moisture (0-100 %)"
  ^double
  [^double wind-speed-10m ^double crown-bulk-density ^double estimated-fine-fuel-moisture]
  (* 11.02
     (Math/pow wind-speed-10m 0.90)
     (Math/pow crown-bulk-density 0.19)
     (Math/exp (* -0.17 estimated-fine-fuel-moisture))))

(defn cruz-passive-crown-fire-spread
  "Returns passive spread-rate in m/min given:
   - active-spread-rate (m/min)
   - critical-spread-rate (m/min)"
  ^double
  [^double active-spread-rate ^double critical-spread-rate]
  (* active-spread-rate
     (Math/exp (- (/ active-spread-rate critical-spread-rate)))))

(defn cruz-crown-fire-spread-metric
  "Returns spread-rate in m/min given:
   - wind-speed-10m (km/hr)
   - crown-bulk-density (kg/m^3)
   - estimated-fine-fuel-moisture (-> M_f :dead :1hr) (0-100 %)
   NOTE: A positive spread-rate indicates active crowning.
         A negative spread-rate indicates passive crowning."
  ^double
  [^double wind-speed-10m ^double crown-bulk-density ^double estimated-fine-fuel-moisture]
  (let [active-spread-rate   (cruz-active-crown-fire-spread wind-speed-10m
                                                            crown-bulk-density
                                                            estimated-fine-fuel-moisture)
        critical-spread-rate (/ 3.0 crown-bulk-density)] ;; m/min
    (if (> active-spread-rate critical-spread-rate)
      active-spread-rate
      (- (cruz-passive-crown-fire-spread active-spread-rate critical-spread-rate))))) ; NOTE: Use minus as passive flag

(defn cruz-crown-fire-spread
  "Returns spread-rate in ft/min given:
   - wind-speed-20ft (mph)
   - crown-bulk-density (lb/ft^3)
   - estimated-fine-fuel-moisture (-> M_f :dead :1hr) (0-1)
   NOTE: A positive spread-rate indicates active crowning.
         A negative spread-rate indicates passive crowning."
  ^double
  [^double wind-speed-20ft ^double crown-bulk-density ^double estimated-fine-fuel-moisture]
  (convert/m->ft
   (cruz-crown-fire-spread-metric
    (-> wind-speed-20ft (convert/mph->km-hr) (convert/wind-speed-20ft->wind-speed-10m))
    (convert/lb-ft3->kg-m3 crown-bulk-density)
    (convert/dec->percent estimated-fine-fuel-moisture))))
#+end_src

Once the crown fire spread rate is determined, the crown fire line
intensity and flame lengths may be derived using the following
formulas:

\begin{align*}
  I_{c} &= \frac{R_{c} B (Z - Z_{b}) h}{60} \\
  L_{c} &= 0.45(I + I_{c})^{0.46}
\end{align*}

where $I_{c}$ is the crown fire line intensity in Btu/ft/s, $R_{c}$ is
the crown fire spread rate (either $\textrm{CROS}_{A}$ or
$\textrm{CROS}_{P}$) in ft/min, $B$ is the crown bulk density in
lb/ft^{3}, $Z$ is the canopy height in ft, $Z_{b}$ is the canopy base
height in ft, $h$ is the fuel model heat of combustion (generally 8000
Btu/lb), $L_{c}$ is the crown flame length in ft, and $I$ is the
surface fire line intensity in Btu/ft/s.

#+name: crown-fire-line-intensity
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :no-expand :comments link
;; heat of combustion is h from the fuel models (generally 8000 Btu/lb)
(defn crown-fire-line-intensity
  "Returns the crown fire line intensity in Btu/ft*s OR kW/m, given:
   - crown spread rate (ft/min OR m/min)
   - crown bulk density (lb/ft^3 OR kg/m^3)
   - canopy height difference (canopy height - canopy base height) (ft OR m)
   - heat of combustion (Btu/lb OR kJ/kg)

   (ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft*min)/60 = Btu/ft*s
   OR
   (m/min * kg/m^3 * m * kJ/kg)/60 = (kJ/m*min)/60 = kJ/m*s = kW/m"
  ^double
  [^double crown-spread-rate ^double crown-bulk-density ^double canopy-height-difference ^double heat-of-combustion]
  (-> crown-spread-rate
      (* crown-bulk-density)
      (* canopy-height-difference)
      (* heat-of-combustion)
      (/ 60.0)))

;; FIXME: unused
(defn crown-fire-line-intensity-elmfire
  "Returns the crown fire line intensity in kW/m, given:
   - surface-fire-line-intensity (kW/m)
   - crown-spread-rate (ft/min)
   - crown-bulk-density (kg/m^3)
   - canopy height difference (canopy height - canopy base height) (m)
   - heat of combustion (kJ/kg) <-- Set to a constant of 18,000 kJ/kg.

   kW/m + (m/min * kg/m^3 * m * kJ/kg)/60 = kW/m + (kJ/m*min)/60 = kW/m + kJ/m*s = kW/m + kW/m = kW/m"
  ^double
  [^double surface-fire-line-intensity ^double crown-spread-rate ^double crown-bulk-density ^double canopy-height-difference]
  (+ surface-fire-line-intensity
     (crown-fire-line-intensity
       (convert/ft->m crown-spread-rate) ;; m/min
       crown-bulk-density
       canopy-height-difference
       18000.0))) ;; kJ/kg
#+end_src

As with surface fire spread, the wind speed (this time the 20-ft wind
speed in mph $U_{20}$) is used to compute the length to width ratio
$\frac{L}{W}$ of an ellipse that approximates the crown fire front
using equation 9 from Rothermel 1991.\citep{Rothermel1991} This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.\citep{Albini1980}
Finally, this eccentricity $E$ is used to project the maximum spread
rate to any point along the fire front. Here are the formulas used:

\begin{align*}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \, \textrm{EAF} \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align*}

where \theta is the angular offset from the direction of maximum fire
spread, R_{max} is the maximum spread rate, R_{\theta} is the spread
rate in direction \theta, and EAF is the ellipse adjustment factor, a
term introduced by Marco Morais and Seth Peterson in their HFire work
that can be increased or decreased to make the fire shape more
elliptical or circular respectively.\citep{Peterson2009}

#+name: crown-eccentricity
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :no-expand :comments link
(defn crown-length-to-width-ratio
  "Calculate the length-to-width ratio of the crown fire front using eq. 9 from
   Rothermel 1991 given:
   - wind-speed-20ft (mph)
   - ellipse-adjustment-factor (dimensionless, < 1.0 circular, > 1.0 elliptical)

   L/W = 1 + 0.125 * U20_mph * EAF"
  ^double
  [^double wind-speed-20ft ^double ellipse-adjustment-factor]
  (-> 0.125
      (* wind-speed-20ft)
      (* ellipse-adjustment-factor)
      (+ 1.0)))

(defn crown-fire-eccentricity
  "Calculate the eccentricity (E) of the crown fire front using eq. 9 from
   Rothermel 1991, and eq. 8 from Albini and Chase 1980 given:
   - wind-speed-20ft (mph)
   - ellipse-adjustment-factor (dimensionless, < 1.0 circular, > 1.0 elliptical)

   L/W = 1 + 0.125 * U20_mph * EAF
   E = sqrt( L/W^2 - 1 ) / L/W"
  ^double
  [^double wind-speed-20ft ^double ellipse-adjustment-factor]
  (let [length-width-ratio (crown-length-to-width-ratio wind-speed-20ft ellipse-adjustment-factor)]
    (-> length-width-ratio
        (Math/pow 2.0)
        (- 1.0)
        (Math/sqrt)
        (/ length-width-ratio))))

;; FIXME: unused
(defn elmfire-length-to-width-ratio
  "true/false mph int>0 ft/min
   Crown L/W = min(1.0 + 0.125*U20_mph, L/W_max)
   Surface L/W = 0.936*e^(0.2566*Ueff_mph) + 0.461*e^(-0.1548*Ueff_mph) - 0.397"
  ^double
  [crown-fire? ^double wind-speed-20ft ^double max-length-to-width-ratio ^double effective-wind-speed]
  (if crown-fire?
    (min (+ 1.0 (* 0.125 wind-speed-20ft)) max-length-to-width-ratio)
    (min (+ (* 0.936 (Math/exp (/ (* 0.2566 effective-wind-speed 60.0) 5280.0)))
            (* 0.461 (Math/exp (/ (* -0.1548 effective-wind-speed 60.0) 5280.0)))
            -0.397)
         8.0)))
#+end_src

This concludes our discussion of the crown fire behavior formulas used
in GridFire.

** Fire Spread on a Raster Grid

Although Rothermel's spread rate formula provides some useful insight
into how quickly a fire's leading edge may travel, it offers no
specific mechanism for simulating fire movement in two or more
dimensions. Therefore, when attempting to use the Rothermel equations
in any spatial analysis, one must begin by choosing a model of space
and then decide how best to employ the spread rate equations along
each possible burn trajectory.

In GridFire, SIG adopted a raster grid view of space so as to reduce the
potentially exponential complexity of modeling a fractal shape (i.e.,
fire front) at high resolutions using vector approximation. This also
provided the practical benefit of being able to work directly with
widely used raster datasets, such as LANDFIRE, without a geometric
lookup step or /a priori/ translation to vector space.

In simulation tests versus FARSITE on several historical California
fires, Marco Morais wrote that he saw similarly accurate results from
both his HFire model and from FARSITE but experienced several orders
of magnitude improvement in runtime
efficiency.\citep{Peterson2011,Peterson2009,Morais2001} His
explanation for this phenomenon was in the same vein as that described
above, namely, that it was FARSITE's choice of vector space that
slowed it down versus the faster raster-based HFire system.

Taking a cue from HFire's success in this regard, GridFire has adopted
HFire's two-dimensional spread algorithm, called the
/method of adaptive timesteps and fractional distances/.
\citep{Peterson2011,Peterson2009,Morais2001} The following
pseudo-code lays out the steps taken in this procedure:

1. Inputs

   1. Read in the values shown in Table [[tab:fire-model-inputs]].

   #+NAME: tab:fire-model-inputs
   #+CAPTION: Inputs to SIG's raster-based fire behavior model
   #+ATTR_LATEX: :align |l|l|l| :font \small
   |---------------------------+-------------------------------------+------------------------------------|
   | Value                     | Units                               | Type                               |
   |---------------------------+-------------------------------------+------------------------------------|
   | max-runtime               | minutes                             | double                             |
   | cell-size                 | feet                                | double                             |
   | elevation-matrix          | feet                                | core.matrix 2D double array        |
   | slope-matrix              | vertical feet/horizontal feet       | core.matrix 2D double array        |
   | aspect-matrix             | degrees clockwise from north        | core.matrix 2D double array        |
   | fuel-model-matrix         | fuel model numbers 1-256            | core.matrix 2D double array        |
   | canopy-height-matrix      | feet                                | core.matrix 2D double array        |
   | canopy-base-height-matrix | feet                                | core.matrix 2D double array        |
   | crown-bulk-density-matrix | lb/ft^{3}                           | core.matrix 2D double array        |
   | canopy-cover-matrix       | 0-100                               | core.matrix 2D double array        |
   | wind-speed-20ft           | miles/hour                          | double                             |
   | wind-from-direction       | degrees clockwise from North        | double                             |
   | fuel-moisture             | %                                   | map of doubles per fuel size class |
   | foliar-moisture           | %                                   | double                             |
   | ellipse-adjustment-factor | $< 1.0 =$ circle, $> 1.0 =$ ellipse | double                             |
   | initial-ignition-site     | point represented as [row col]      | vector                             |
   |---------------------------+-------------------------------------+------------------------------------|

2. Initialization

   1. Verify that *initial-ignition-site* and at least one of its
      neighboring cells has a burnable fuel model (not 91-99).
      Otherwise, terminate the simulation, indicating that no fire
      spread is possible.

   2. Create three new matrices, called *fire-spread-matrix*,
      *flame-length-matrix*, and *fire-line-intensity-matrix*. All
      three are initialized to zero except for a value of 1 at the
      *initial-ignition-site*.

   3. Set *global-clock* to 0. This will track the amount of time that
      has passed since the initial ignition in minutes.

   4. Create a new hash-map, called *ignited-cells*, which maps the
      *initial-ignition-site* to a set of trajectories into each of
      its burnable neighbors. See ``Computing Burn Trajectories''
      below for the steps used in this procedure.

3. Computing Burn Trajectories

   1. Look up the fuel model, slope, aspect, canopy height, canopy
      base height, crown bulk density, and canopy cover associated
      with the ignited cell in the input matrices.

   2. Calculate the dead herbaceous size class parameters, live
      moisture of extinction, and size class weighting factors for
      this fuel model.

   3. Use the Rothermel equations to calculate the minimum surface
      rate of spread (i.e., wind = slope = 0) leaving this cell.

   4. Compute Albini and Baughman's wind adjustment factor for this
      cell using the fuel bed depth, canopy height, and canopy cover.
      Multiply this value by the 20-ft wind speed to derive the local
      midflame wind speed.

   5. Calculate the maximum surface rate of spread (and bearing)
      originating from this cell using the Rothermel equations and
      taking into account the effects of downhill and cross-slope
      winds as described in Rothermel 1983.

   6. Use the Cruz formulas to calculate the maximum crown fire spread
      rate from the 20-ft wind speed, crown bulk density, and dead
      1-hr fuel moisture.

   7. Determine the surface and crown elliptical eccentricities by
      calculating their length-to-width ratios using the equations
      from Rothermel 1991.

   8. For each burnable neighboring cell:

      1. Use the eccentricity values to determine the possible surface
         and crown rates of spread into it from the ignited cell.

      2. Compute Byram's surface fire line intensity and Rothermel's
         crown intensity from these spread rates.

      3. Apply Van Wagner's crown initiation model to determine if the
         fire will be a passive or active crown fire or remain a
         surface fire.

      4. In the surface fire case, the spread rate into this neighbor
         will simply be the surface spread rate calculated above. The
         fire line intensity is the surface fire line intensity, and
         the flame length is calculated from this intensity value
         using Byram's relation.

      5. In the case of a crown fire, the spread rate into this
         neighbor will be the maximum of the surface and crown spread
         rates. The fire line intensity is the sum of the surface and
         crown intensities, and the flame length is once again
         computed from Byram's relation.

      6. Store this neighboring cell, the bearing to it from the
         ignited cell, and the spread rate, fire line intensity, and
         flame length values computed above in a burn trajectory
         record. Also include the terrain (e.g., 3d) distance between
         this cell and the ignited cell. Finally, set its
         *fractional-distance* value to be 0, or in the event that
         this bearing matches an overflow bearing from a previous
         iteration, set it to the *overflow-heat* value.

   9. Return a collection of burn trajectory records, one per burnable
      neighboring cell.

4. Main Loop

   1. If *global-clock* has not yet reached *max-runtime* and
      *ignited-cells* is not empty, proceed to 4.(b). Otherwise, jump
      to 5.(a).

   2. The timestep for this iteration of the model is calculated by
      dividing *cell-size* by the maximum spread rate into any cell
      from those cells in the *ignited-cells* map. As spread rates
      increase, the timesteps grow shorter and the model takes more
      iterations to complete. Similarly, the model has longer
      timesteps and takes less iterations as spread rates decrease.
      This is called the /method of adaptive timesteps/.

   3. If the timestep calculated in 4.(b) would cause the
      *global-clock* to exceed the max-runtime, then the timestep is
      set to the difference between *max-runtime* and *global-clock*.

   4. For each burn trajectory in *ignited-cells*:

      1. Multiply the spread rate (ft/min) by the timestep (min) to
         get the distance traveled by the fire (ft) along this path
         during this iteration.

      2. Divide this distance traveled by the terrain distance between
         these two cells to get the new spread fraction $\in [0,1]$
         and increment the *fractional-distance* associated with the
         trajectory by this value.

      3. If the new *fractional-distance* is greater than or equal to
         1, append this updated burn trajectory record to a list
         called *ignition-events*.

   5. If more than one trajectory in *ignition-events* shares the same
      target cell, retain only the trajectory with the largest
      *fractional-distance* value.

   6. For each trajectory in *ignition-events*:

      1. Set the target cell's value to 1 in *fire-spread-matrix*,
         *flame-length* in *flame-length-matrix*, and
         *fire-line-intensity* in *fire-line-intensity-matrix*.

      2. If the target cell has any burnable neighbors, append an
         entry to *ignited-cells*, mapping this cell to each of the
         burn trajectories emanating from it, which are calculated by
         following the steps in section ``Computing Burn
         Trajectories'' above. If its *fractional-distance* value is
         greater than 1, add the overflow amount above 1 to the
         outgoing trajectory with the same bearing along which this
         cell was ignited. That is, if this cell was ignited by a
         neighbor to the southeast, then pass any overflow heat onto
         the trajectory leading to the northwest.

   7. Remove any trajectories from *ignited-cells* that have as their
      targets any of the cells in *ignition-events*.

   8. Remove any cells from *ignited-cells* that no longer have any
      burnable neighbors.

   9. Increment the *global-clock* by this iteration's *timestep*.

   10. Repeat from 4.(a).

5. Outputs

   1. Return an associative map with the fields shown in Table
      [[tab:fire-model-outputs]].

   #+NAME: tab:fire-model-outputs
   #+CAPTION: Outputs from SIG's raster-based fire behavior model
   #+ATTR_LATEX: :align |l|l|l| :font \small
   |----------------------------+-----------------------------------------+-----------------------------|
   | Value                      | Units                                   | Type                        |
   |----------------------------+-----------------------------------------+-----------------------------|
   | global-clock               | minutes                                 | double                      |
   | initial-ignition-site      | point represented as [row col]          | vector                      |
   | ignited-cells              | list of points represented as [row col] | list of vectors             |
   | fire-spread-matrix         | [0,1]                                   | core.matrix 2D double array |
   | flame-length-matrix        | feet                                    | core.matrix 2D double array |
   | fire-line-intensity-matrix | Btu/ft/s                                | core.matrix 2D double array |
   |----------------------------+-----------------------------------------+-----------------------------|

#+name: fire-spread-algorithm
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fire_spread.clj :padline no :no-expand :comments link
(ns gridfire.fire-spread
  (:require [clojure.core.reducers         :as r]
            [gridfire.common               :refer [burnable-fuel-model?
                                                   burnable?
                                                   calc-fuel-moisture
                                                   in-bounds?
                                                   burnable-neighbors?
                                                   get-neighbors
                                                   distance-3d
                                                   non-zero-indices]]
            [gridfire.conversion          :refer [mph->fpm]]
            [gridfire.crown-fire          :refer [crown-fire-eccentricity
                                                  crown-fire-line-intensity
                                                  cruz-crown-fire-spread
                                                  van-wagner-crown-fire-initiation?]]
            [gridfire.fire-spread-optimal :refer [rothermel-fast-wrapper-optimal]]
            [gridfire.fuel-models         :refer [build-fuel-model moisturize]]
            [gridfire.spotting            :as spot]
            [gridfire.surface-fire        :refer [anderson-flame-depth
                                                  byram-fire-line-intensity
                                                  byram-flame-length
                                                  rothermel-surface-fire-spread-any
                                                  rothermel-surface-fire-spread-max
                                                  rothermel-surface-fire-spread-no-wind-no-slope
                                                  wind-adjustment-factor]]
            [gridfire.fuel-models-optimal  :as f-opt]
            [gridfire.surface-fire-optimal :as s-opt]
            [tech.v3.datatype             :as d]
            [tech.v3.datatype.functional  :as dfn]
            [tech.v3.tensor               :as t]
            [taoensso.tufte :as tufte]))

;; for surface fire, tau = 10 mins, t0 = 0, and t = global-clock
;; for crown fire, tau = 20 mins, t0 = time of first torch, t = global-clock
;; (defn lautenberger-spread-acceleration
;;   [equilibrium-spread-rate t0 t tau]
;;   (* equilibrium-spread-rate (- 1.0 (Math/exp (/ (- t0 t 0.2) tau)))))
;;
;; Note: Because of our use of adaptive timesteps, if the spread rate on
;;       the first timestep is not at least 83 ft/min, then the timestep will
;;       be calculated as greater than 60 minutes, which will terminate the
;;       one hour fire simulation instantly.

(defn random-cell
  "Returns a random [i j] pair with i < num-rows and j < num-cols."
  [num-rows num-cols]
  [(rand-int num-rows)
   (rand-int num-cols)])

(def offset-to-degrees
  "Returns clockwise degrees from north."
  {[-1  0] 0.0   ; N
   [-1  1] 45.0  ; NE
   [ 0  1] 90.0  ; E
   [ 1  1] 135.0 ; SE
   [ 1  0] 180.0 ; S
   [ 1 -1] 225.0 ; SW
   [ 0 -1] 270.0 ; W
   [-1 -1] 315.0}) ; NW

(defn rothermel-fast-wrapper
  [fuel-model-number fuel-moisture grass-suppression?]
  (let [fuel-model      (-> (build-fuel-model (int fuel-model-number))
                            (moisturize fuel-moisture))
        spread-info-min (rothermel-surface-fire-spread-no-wind-no-slope fuel-model grass-suppression?)]
    [fuel-model spread-info-min]))

(defrecord BurnTrajectory
    [cell
     source
     trajectory ;;=> use integer, bit, or angle
     ^double terrain-distance
     ^double spread-rate
     ^double fire-line-intensity
     ^double flame-length
     fractional-distance
     fire-type
     crown-fire?])

(defn compute-burn-trajectory
  [neighbor here surface-fire-min surface-fire-max crown-bulk-density
   canopy-cover canopy-height canopy-base-height foliar-moisture crown-spread-max
   crown-eccentricity elevation-matrix cell-size overflow-trajectory overflow-heat
   crown-type]
  (let [trajectory                (mapv - neighbor here)
        spread-direction          (offset-to-degrees trajectory)
        surface-spread-rate       (rothermel-surface-fire-spread-any surface-fire-max
                                                                     spread-direction)
        residence-time            (:residence-time surface-fire-min)
        reaction-intensity        (:reaction-intensity surface-fire-min)
        surface-intensity         (->> (anderson-flame-depth surface-spread-rate residence-time)
                                       (byram-fire-line-intensity reaction-intensity))
        crown-fire?               (van-wagner-crown-fire-initiation? canopy-cover
                                                                     canopy-base-height
                                                                     foliar-moisture
                                                                     surface-intensity)
        ^double crown-spread-rate (when crown-fire?
                                    (rothermel-surface-fire-spread-any
                                     (assoc surface-fire-max
                                            :max-spread-rate crown-spread-max
                                            :eccentricity crown-eccentricity)
                                     spread-direction))
        ^double crown-intensity   (when crown-fire?
                                    (crown-fire-line-intensity crown-spread-rate
                                                               crown-bulk-density
                                                               (- canopy-height canopy-base-height)
                                                               (:heat-of-combustion surface-fire-min))) ; 0 = dead-1hr
        spread-rate               (if crown-fire?
                                    (max surface-spread-rate crown-spread-rate)
                                    surface-spread-rate)
        fire-line-intensity       (if crown-fire?
                                    (+ surface-intensity crown-intensity)
                                    surface-intensity)
        flame-length              (byram-flame-length fire-line-intensity)]
    (->BurnTrajectory neighbor
                      here
                      trajectory
                      (distance-3d elevation-matrix cell-size here neighbor)
                      spread-rate
                      fire-line-intensity
                      flame-length
                      (volatile! (if (= trajectory overflow-trajectory)
                                   overflow-heat
                                   0.0))
                      (if crown-fire? crown-type :surface)
                      crown-fire?)))

;;TODO Optimize me!
(defn compute-neighborhood-fire-spread-rates!
  "Returns a vector of entries of the form:
  {:cell [i j],
   :trajectory [di dj],
   :terrain-distance ft,
   :spread-rate ft/min,
   :fire-line-intensity Btu/ft/s,
   :flame-length ft,
   :fractional-distance [0-1]}, one for each cell adjacent to here."
  [{:keys
    [get-aspect get-canopy-base-height get-canopy-cover get-canopy-height get-crown-bulk-density
     get-fuel-model get-slope elevation-matrix fuel-model-matrix get-wind-speed-20ft
     get-wind-from-direction get-temperature get-relative-humidity get-foliar-moisture
     ellipse-adjustment-factor cell-size num-rows num-cols get-fuel-moisture-dead-1hr
     get-fuel-moisture-dead-10hr get-fuel-moisture-dead-100hr get-fuel-moisture-live-herbaceous
     get-fuel-moisture-live-woody grass-suppression?]}
   fire-spread-matrix
   [i j :as here]
   overflow-trajectory
   overflow-heat
   global-clock]
  (let [band                                        (int (/ global-clock 60.0))
        ^double aspect                              (get-aspect i j)
        ^double canopy-base-height                  (get-canopy-base-height i j)
        ^double canopy-height                       (get-canopy-height i j)
        ^double canopy-cover                        (get-canopy-cover i j)
        ^double crown-bulk-density                  (get-crown-bulk-density i j)
        ^double fuel-model                          (get-fuel-model i j)
        ^double slope                               (get-slope i j)
        ^double relative-humidity                   (get-relative-humidity band i j)
        ^double temperature                         (get-temperature band i j)
        ^double wind-speed-20ft                     (get-wind-speed-20ft band i j)
        ^double wind-from-direction                 (get-wind-from-direction band i j)
        ^double fuel-moisture-dead-1hr              (if get-fuel-moisture-dead-1hr
                                                      (get-fuel-moisture-dead-1hr band i j)
                                                      (calc-fuel-moisture relative-humidity temperature :dead :1hr))
        ^double fuel-moisture-dead-10hr             (if get-fuel-moisture-dead-10hr
                                                      (get-fuel-moisture-dead-10hr band i j)
                                                      (calc-fuel-moisture relative-humidity temperature :dead :10hr))
        ^double fuel-moisture-dead-100hr            (if get-fuel-moisture-dead-100hr
                                                      (get-fuel-moisture-dead-100hr band i j)
                                                      (calc-fuel-moisture relative-humidity temperature :dead :100hr))
        ^double fuel-moisture-live-herbaceous       (if get-fuel-moisture-live-herbaceous
                                                      (get-fuel-moisture-live-herbaceous i j)
                                                      (calc-fuel-moisture relative-humidity temperature :live :herbaceous))
        ^double fuel-moisture-live-woody            (if get-fuel-moisture-live-woody
                                                      (get-fuel-moisture-live-woody i j)
                                                      (calc-fuel-moisture relative-humidity temperature :live :woody))
        ^double foliar-moisture                     (get-foliar-moisture band i j)
        surface-fire-min                            (rothermel-fast-wrapper-optimal
                                                     fuel-model
                                                     [fuel-moisture-dead-1hr
                                                      fuel-moisture-dead-10hr
                                                      fuel-moisture-dead-100hr
                                                      0.0 ; fuel-moisture-dead-herbaceous
                                                      fuel-moisture-live-herbaceous
                                                      fuel-moisture-live-woody]
                                                     grass-suppression?)
        midflame-wind-speed                         (mph->fpm
                                                     (* wind-speed-20ft
                                                        (wind-adjustment-factor (:fuel-bed-depth surface-fire-min)
                                                                                canopy-height
                                                                                canopy-cover)))
        surface-fire-max                            (rothermel-surface-fire-spread-max surface-fire-min
                                                                                       midflame-wind-speed
                                                                                       wind-from-direction
                                                                                       slope
                                                                                       aspect
                                                                                       ellipse-adjustment-factor)
        crown-spread-max                            (cruz-crown-fire-spread wind-speed-20ft crown-bulk-density fuel-moisture-dead-1hr)
        crown-type                                  (if (neg? crown-spread-max) :passive-crown :active-crown)
        crown-spread-max                            (Math/abs crown-spread-max)
        crown-eccentricity                          (crown-fire-eccentricity wind-speed-20ft
                                                                             ellipse-adjustment-factor)]
    (into []
          (comp
           (filter #(and (in-bounds? num-rows num-cols %)
                         (burnable? fire-spread-matrix fuel-model-matrix here %)))
           (map #(compute-burn-trajectory % here surface-fire-min surface-fire-max
                                          crown-bulk-density canopy-cover canopy-height
                                          canopy-base-height foliar-moisture crown-spread-max
                                          crown-eccentricity elevation-matrix cell-size
                                          overflow-trajectory overflow-heat crown-type)))
          (get-neighbors here))))

(defn- get-old-fractional-distance
  [{:keys [trajectory-combination]} {:keys [fractional-distance]} fractional-distance-matrix [i j]]
  (if (= trajectory-combination :sum)
    (t/mget fractional-distance-matrix i j)
    @fractional-distance))

(defn- update-fractional-distance-matrix!
  "Update the fractional distance matrix with the largest fractional distance calculated."
  [fractional-distance-matrix max-fractionals]
  (doseq [[cell fractional-distance] @max-fractionals]
    (let [[i j] cell]
      (t/mset! fractional-distance-matrix i j fractional-distance))))

(defn- update-fractional-distance!
  "Update fractional distance for given trajectory into the current cell. Return a tuple of [old-value new-value]"
  [{:keys [trajectory-combination] :as inputs} max-fractionals trajectory fractional-distance-matrix timestep cell]
  (let [terrain-distance    (double (:terrain-distance trajectory))
        spread-rate         (double (:spread-rate trajectory)) ;TODO recompute spread rates when crossing hourly boundary
        new-spread-fraction (/ (* spread-rate timestep) terrain-distance)
        old-total           (get-old-fractional-distance inputs trajectory fractional-distance-matrix cell)
        new-total           (+ old-total new-spread-fraction)]
    (if (= trajectory-combination :sum)
      (let [max-fractional-distance (max (get @max-fractionals cell 0.0) new-total)]
        (swap! max-fractionals assoc cell max-fractional-distance))
      (vreset! (:fractional-distance trajectory) new-total))
    [old-total new-total]))

(defn- update-overflow-heat
  [{:keys [num-rows num-cols]} fractional-distance-matrix {:keys [cell trajectory]} fractional-distance]
  (let [[i j :as target] (mapv + cell trajectory)]
    (when (in-bounds? num-rows num-cols target)
      (t/mset! fractional-distance-matrix i j (- fractional-distance 1.0)))))

(defn ignition-event-reducer
  [inputs max-fractionals fractional-distance-matrix timestep trajectory-combination fire-spread-matrix
   acc trajectory]
  (let [{:keys [source cell]}                 trajectory ;TODO cell -> target
        [i j]                                 source
        [^double old-total ^double new-total] (update-fractional-distance! inputs
                                                                           max-fractionals
                                                                           trajectory
                                                                           fractional-distance-matrix
                                                                           timestep
                                                                           cell)]
    (if (and (>= new-total 1.0)
             (> new-total ^double (get-in acc [cell :fractional-distance] 0.0)))
      (do (when (and (= trajectory-combination :sum) (> new-total 1.0))
            (update-overflow-heat inputs fractional-distance-matrix trajectory new-total))
          (assoc! acc cell (merge trajectory {:fractional-distance  new-total
                                              :dt-adjusted          (* (/ (- 1.0 old-total) (- new-total old-total))
                                                                       timestep)
                                              :ignition-probability (t/mget fire-spread-matrix i j)})))
      acc)))

(defn find-new-ignitions ;51%
  [{:keys [trajectory-combination] :as inputs}
   {:keys [fire-spread-matrix fractional-distance-matrix]}
   burn-trajectories
   ^double timestep]
  (let [max-fractionals (atom {})
        reducer-fn      (fn [acc trajectory]
                          (ignition-event-reducer inputs max-fractionals fractional-distance-matrix
                                                  timestep trajectory-combination fire-spread-matrix
                                                  acc trajectory))
        ignition-events (->> burn-trajectories
                             (reduce reducer-fn (transient {}))
                             persistent!
                             vals)]
    (when (= trajectory-combination :sum)
      (update-fractional-distance-matrix! fractional-distance-matrix max-fractionals))
    ignition-events))

;; Tufte 31%
(defn update-burn-trajectories
  [{:keys [fuel-model-matrix num-rows num-cols parallel-strategy] :as constants}
   burn-trajectories
   ignition-events
   fire-spread-matrix
   global-clock]
  (let [parallel-bin-size        (max 1 (quot (count ignition-events) (.availableProcessors (Runtime/getRuntime))))
        newly-burn-trajectories  (into #{} (map :cell) ignition-events)
        pruned-burn-trajectories (into [] (remove #(contains? newly-burn-trajectories (:cell %))) burn-trajectories)
        reducer-fn               (if (= parallel-strategy :within-fires)
                                   #(->> (r/fold parallel-bin-size r/cat r/append! %)
                                         (reduce (fn [acc v] (into acc v)) pruned-burn-trajectories))
                                   #(reduce (fn [acc v] (into acc v)) pruned-burn-trajectories %))]
    (->> ignition-events
         (r/map (fn [{:keys [cell trajectory fractional-distance]}]
                  (let [fractional-distance (double fractional-distance)]
                    (when (burnable-neighbors? fire-spread-matrix
                                               fuel-model-matrix
                                               num-rows num-cols
                                               cell)
                      (compute-neighborhood-fire-spread-rates!
                       constants
                       fire-spread-matrix
                       cell
                       trajectory
                       (- fractional-distance 1.0)
                       global-clock)))))
         (r/remove nil?)
         (reducer-fn))))

(defn generate-burn-trajectories
  [inputs fire-spread-matrix cells]
  (reduce (fn [burn-trajectories cell]
            (into burn-trajectories
                  (compute-neighborhood-fire-spread-rates! inputs
                                                           fire-spread-matrix
                                                           cell
                                                           nil
                                                           0.0
                                                           0.0)))
          []
          cells))

(defn identify-spot-ignition-events
  [global-clock spot-ignitions]
  (let [to-ignite-now (group-by (fn [[_ [time _]]]
                                  (let [time (double time)]
                                    (>= ^double global-clock time)))
                                spot-ignitions)
        ignite-later  (into {} (get to-ignite-now false))
        ignite-now    (into {} (get to-ignite-now true))]
    [ignite-later ignite-now]))

(defn spot-burn-trajectories
  "Updates matrices for spot ignited cells
  Returns a map of ignited cells"
  [constants
   global-clock
   {:keys [fire-spread-matrix burn-time-matrix spread-rate-matrix fire-type-matrix
           flame-length-matrix fire-line-intensity-matrix spot-matrix]}
   spot-ignite-now]
  (let [ignited?          (fn [[k v]]
                            (let [[i j] k
                                  [_ p] v]
                              (> ^double (t/mget fire-spread-matrix i j) ^double p)))
        spot-ignite-now   (remove ignited? spot-ignite-now)
        burn-trajectories (generate-burn-trajectories constants
                                                      fire-spread-matrix
                                                      (keys spot-ignite-now))]
    (doseq [cell spot-ignite-now
            :let [[i j]                    (key cell)
                  [_ ignition-probability] (val cell)]]
      (t/mset! fire-spread-matrix i j ignition-probability)
      (t/mset! burn-time-matrix i j global-clock)
      (t/mset! flame-length-matrix i j 1.0)
      (t/mset! fire-line-intensity-matrix i j 1.0)
      (t/mset! spread-rate-matrix i j -1.0)
      (t/mset! fire-type-matrix i j -1.0)
      (t/mset! spot-matrix i j 1.0))
    burn-trajectories))

(defn new-spot-ignitions
  "Returns a map of [x y] locations to [t p] where:
  t: time of ignition
  p: ignition-probability"
  [{:keys [spotting] :as inputs} matrices ignition-events global-clock]
  (when spotting
    (reduce (fn [acc ignition-event]
              (merge-with (partial min-key first)
                          acc
                          (->> (spot/spread-firebrands
                                inputs
                                matrices
                                ignition-event
                                global-clock)
                               (into {}))))
            {}
            ignition-events)))

(def fire-type-to-value
  {:surface       1.0
   :passive-crown 2.0
   :active-crown  3.0})

(defn- find-max-spread-rate ^double
  [^double max-spread-rate ^BurnTrajectory burn-trajectory]
  (Math/max max-spread-rate ^double (:spread-rate burn-trajectory)))

(defn- compute-dt ^double
  [^double cell-size burn-trajectories]
  (if (seq burn-trajectories)
    (let [max-spread-rate (double (reduce find-max-spread-rate 0.0 burn-trajectories))]
      (/ cell-size max-spread-rate))
    10.0))

(defn- compute-spot-trajectories
  [inputs matrices global-clock ignition-events spot-ignitions]
  (let [new-spot-ignitions     (new-spot-ignitions inputs ;TODO optimize
                                                   matrices
                                                   ignition-events
                                                   global-clock)
        [spot-ignite-later
         spot-ignite-now]      (identify-spot-ignition-events global-clock ;TODO optimize
                                                              (merge-with (partial min-key first)
                                                                          spot-ignitions
                                                                          new-spot-ignitions))
        spot-burn-trajectories (spot-burn-trajectories inputs ;TODO optimize
                                                       global-clock
                                                       matrices
                                                       spot-ignite-now)]
    [spot-ignite-later spot-burn-trajectories]))

(defn- store-ignition-events!
  [{:keys [fire-spread-matrix flame-length-matrix fire-line-intensity-matrix burn-time-matrix
           spread-rate-matrix fire-type-matrix]}
   global-clock
   ignition-events]
  (doseq [{:keys
           [cell flame-length fire-line-intensity
            ignition-probability spread-rate fire-type
            dt-adjusted]} ignition-events] ;TODO investigate using records for ignition-events
    (let [[i j] cell]
      (t/mset! fire-spread-matrix         i j ignition-probability)
      (t/mset! flame-length-matrix        i j flame-length)
      (t/mset! fire-line-intensity-matrix i j fire-line-intensity)
      (t/mset! burn-time-matrix           i j (+ global-clock ^double dt-adjusted))
      (t/mset! spread-rate-matrix         i j spread-rate)
      (t/mset! fire-type-matrix           i j (fire-type fire-type-to-value))))) ;TODO Use number

(defn run-loop
  [{:keys [max-runtime cell-size ignition-start-time] :as inputs}
   {:keys
    [fire-spread-matrix flame-length-matrix fire-line-intensity-matrix burn-time-matrix
     spread-rate-matrix fire-type-matrix fractional-distance-matrix spot-matrix] :as matrices}
   ignited-cells]
  (let [max-runtime         (double max-runtime)
        cell-size           (double cell-size)
        ignition-start-time (double ignition-start-time)
        ignition-stop-time  (+ ignition-start-time max-runtime)]
    (loop [global-clock      ignition-start-time
           burn-trajectories (generate-burn-trajectories inputs fire-spread-matrix ignited-cells)
           spot-ignitions    {}
           spot-count        0
           crown-count       0]
      (if (and (< global-clock ignition-stop-time)
               (or (seq burn-trajectories) (seq spot-ignitions)))
        (let [timestep        (Math/min (compute-dt cell-size burn-trajectories)
                                        (- ignition-stop-time global-clock))
              ignition-events (find-new-ignitions inputs matrices burn-trajectories timestep)]
          (store-ignition-events! matrices global-clock ignition-events)
          (let [[spot-ignite-later
                 spot-burn-trajectories] (compute-spot-trajectories inputs matrices global-clock
                                                                    ignition-events spot-ignitions)]
            (recur (+ global-clock timestep)
                   (update-burn-trajectories inputs
                                             (into spot-burn-trajectories burn-trajectories)
                                             ignition-events
                                             fire-spread-matrix
                                             global-clock)
                   spot-ignite-later
                   (+ spot-count (count spot-burn-trajectories))
                   (+ crown-count (count (filterv :crown-fire? ignition-events))))))
        {:global-clock               global-clock
         :exit-condition             (if (>= global-clock ignition-stop-time) :max-runtime-reached :no-burnable-fuels)
         :fire-spread-matrix         fire-spread-matrix
         :flame-length-matrix        flame-length-matrix
         :fire-line-intensity-matrix fire-line-intensity-matrix
         :burn-time-matrix           burn-time-matrix
         :spot-matrix                spot-matrix
         :spread-rate-matrix         spread-rate-matrix
         :fire-type-matrix           fire-type-matrix
         :crown-fire-count           crown-count
         :spot-count                 spot-count}))))

(defmulti run-fire-spread
  "Runs the raster-based fire spread model with a map of these arguments:
  - max-runtime: double (minutes)
  - cell-size: double (feet)
  - elevation-matrix: core.matrix 2D double array (feet)
  - slope-matrix: core.matrix 2D double array (vertical feet/horizontal feet)
  - aspect-matrix: core.matrix 2D double array (degrees clockwise from north)
  - fuel-model-matrix: core.matrix 2D double array (fuel model numbers 1-256)
  - canopy-height-matrix: core.matrix 2D double array (feet)
  - canopy-base-height-matrix: core.matrix 2D double array (feet)
  - crown-bulk-density-matrix: core.matrix 2D double array (lb/ft^3)
  - canopy-cover-matrix: core.matrix 2D double array (0-100)
  - wind-speed-20ft: double (miles/hour)
  - wind-from-direction: double (degrees clockwise from north)
  - fuel-moisture: doubles (0-1) {:dead {:1hr :10hr :100hr} :live {:herbaceous :woody}}
  - foliar-moisture: double (0-1)
  - ellipse-adjustment-factor: (< 1.0 = more circular, > 1.0 = more elliptical)
  - initial-ignition-site: One of the following:
     - point represented as [row col]
     - a core.matrix 2D double array (0-2)
  - num-rows: integer
  - num-cols: integer"
  (fn [{:keys [initial-ignition-site]}]
    (if (vector? initial-ignition-site)
      :ignition-point
      :ignition-perimeter)))

;;-----------------------------------------------------------------------------
;; Igniiton Point
;;-----------------------------------------------------------------------------

(defn- initialize-point-ignition-matrices
  [{:keys [num-rows num-cols initial-ignition-site ignition-start-time spotting trajectory-combination]}]
  (let [[i j]                      initial-ignition-site
        shape                      [num-rows num-cols]
        burn-time-matrix           (t/new-tensor shape)
        fire-line-intensity-matrix (t/new-tensor shape)
        fire-spread-matrix         (t/new-tensor shape)
        fire-type-matrix           (t/new-tensor shape)
        firebrand-count-matrix     (when spotting (t/new-tensor shape))
        flame-length-matrix        (t/new-tensor shape)
        fractional-distance-matrix (when (= trajectory-combination :sum) (t/new-tensor shape))
        spot-matrix                (t/new-tensor shape) ;;TODO check if spot-matrix requires spotting
        spread-rate-matrix         (t/new-tensor shape)]
    (t/mset! burn-time-matrix i j ignition-start-time)
    (t/mset! fire-line-intensity-matrix i j 1.0)       ;TODO should this be zero?
    (t/mset! fire-spread-matrix i j 1.0)
    (t/mset! fire-type-matrix i j -1.0)                ;TODO should this be zero?
    (t/mset! flame-length-matrix i j 1.0)              ;TODO should this be zero?
    (t/mset! spread-rate-matrix i j -1.0)              ;TODO should this be zero?
    {:burn-time-matrix           burn-time-matrix
     :fire-line-intensity-matrix fire-line-intensity-matrix
     :fire-spread-matrix         fire-spread-matrix
     :fire-type-matrix           fire-type-matrix
     :firebrand-count-matrix     firebrand-count-matrix
     :flame-length-matrix        flame-length-matrix
     :fractional-distance-matrix fractional-distance-matrix
     :spot-matrix                spot-matrix
     :spread-rate-matrix         spread-rate-matrix}))

(defmethod run-fire-spread :ignition-point
  [{:keys [initial-ignition-site] :as inputs}]
  (run-loop inputs (initialize-point-ignition-matrices inputs) [initial-ignition-site]))

;;-----------------------------------------------------------------------------
;; Ignition Perimeter
;;-----------------------------------------------------------------------------

(defn- initialize-perimeter-ignition-matrices
  [{:keys [num-rows num-cols spotting trajectory-combination initial-ignition-site]}]
  (let [shape              [num-rows num-cols]
        positive-burn-scar initial-ignition-site
        negative-burn-scar (d/clone (dfn/* -1.0 positive-burn-scar))]
    {:burn-time-matrix           negative-burn-scar
     :fire-line-intensity-matrix (d/clone negative-burn-scar)
     :fire-spread-matrix         (d/clone positive-burn-scar)
     :fire-type-matrix           (d/clone negative-burn-scar)
     :firebrand-count-matrix     (when spotting (t/new-tensor shape))
     :flame-length-matrix        (d/clone negative-burn-scar)
     :fractional-distance-matrix (when (= trajectory-combination :sum) (d/clone positive-burn-scar))
     :spot-matrix                (t/new-tensor shape) ;TODO check if spot-matrix requires spotting
     :spread-rate-matrix         (d/clone negative-burn-scar)}))

(defn- get-non-zero-indices [m]
  (let [{:keys [row-idxs col-idxs]} (non-zero-indices m)]
    (map vector row-idxs col-idxs)))

(defmethod run-fire-spread :ignition-perimeter
  [{:keys [num-rows num-cols initial-ignition-site fuel-model-matrix] :as inputs}]
  (when-let [ignited-cells (->> (get-non-zero-indices initial-ignition-site)
                                  (filter #(burnable-neighbors? initial-ignition-site
                                                                fuel-model-matrix
                                                                num-rows
                                                                num-cols
                                                                %))
                                  seq)]
    (run-loop inputs (initialize-perimeter-ignition-matrices inputs) ignited-cells)))
#+end_src

This concludes our description of GridFire's raster-based fire spread
algorithm.

** Spotting Model Forumulas

Gridfire can optionally include spot fires using a cellular automata model
described in Perryman 2013. The model is broken up into four submodels:
Surface Spread, Tree Torching, Firebrand Dispersal, and Spot Ignition. For
Surface Spread and Tree Torching, the Perryman model uses Rothermal (1972) and
Van Wagner 1977 respectively. Gridfire will use the same models described in
the previous sections.

The Firebrand Dispersal model describes the distributions of firebrands relative
to the wind direction. The location of where the firebrand lands is determined
by the probabilties of landing d meters in the direction parallel and
perpendicular to the wind.

For determining the distance a firebrands should land parallel to the wind a
lognormal probability density function is used from Sardoy (2008). Instead
of calculating the probability GridFire will sample using a log-normal
distribution using the mean and standard deviations derived from the fireline
intensity and wind speed (Sardoy 2008).

Mean and spotting distance (/m/) and it's variance (/v/):

\begin{align*}
m = aQ^{b} * U^{c}
\end{align*}

\begin{align*}
v = m * d
\end{align*}

The emperical parameters a,b,c, and d is specified directly (see
section 8 in Confguration File)

a = mean-distance

b = flin-exp

c = ws-exp

d = normalized-distance-variance

The normalized mean (\mu) and standard deviation (\sigma) of the
lognormal distribution are then calculated from /m/ and /v/ as:

\begin{align*}
\mu = ln(\frac{m^2}{\sqrt{v + m^{2}}})
\end{align*}

\begin{align*}
\sigma = \sqrt{ln(1 + \frac{v}{m^{2}})}
\end{align*}

The above values are used to plugged into the lognormal distribution
function:

\begin{align*}
f(d) = \frac{1}{\sqrt{2 \pi \sigma x}} exp (-\frac{1}{2} \frac{ln(d) - \mu}{\sigma}^2)
\end{align*}

Instead of implementing this function Gridfire uses the log-normal
function from kixi.stats (a Clojure/Clojurescript library of
statistical sampling and transducing functions).

For determining the distance a firebrands should land perpendicular to the wind
a normal distribution with the mean of 0 and standard deviation of 0.92 is used,
as described in Himoto and Tanaka (2005) (referenced in Perryman).

Once we have the mean and standard deviation we can sample using log-normal
distribution for the direction parallel to the wind and normal distribution for
the direction perpendicular to the wind.

#+name: sardoy-firebrand-dispersal
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/spotting.clj :padline no :no-expand :comments link
(ns gridfire.spotting
  (:require [gridfire.common       :refer [distance-3d
                                           calc-fuel-moisture
                                           in-bounds?
                                           burnable?]]
            [gridfire.utils.random :refer [my-rand-range]]
            [gridfire.conversion   :as convert]
            [tech.v3.tensor        :as t])
  (:import java.util.Random))

;;-----------------------------------------------------------------------------
;; Formulas
;;-----------------------------------------------------------------------------

(defn- sample-spotting-params
  ^double
  [param rand-gen]
  (if (map? param)
    (let [{:keys [lo hi]} param
          l               (if (vector? lo) (my-rand-range rand-gen (lo 0) (lo 1)) lo)
          h               (if (vector? hi) (my-rand-range rand-gen (hi 0) (hi 1)) hi)]
      (my-rand-range rand-gen l h))
    param))

(defn- mean-variance
  "Returns mean spotting distance and it's variance given:
  fire-line-intensity: (kWm^-1)
  wind-speed-20ft: (ms^-1)"
  [{:keys [^double mean-distance ^double flin-exp ^double ws-exp ^double normalized-distance-variance]}
   rand-gen ^double fire-line-intensity ^double wind-speed-20ft]
  (let [a (sample-spotting-params mean-distance rand-gen)
        b (sample-spotting-params flin-exp rand-gen)
        c (sample-spotting-params ws-exp rand-gen)
        m (* a (Math/pow fire-line-intensity b) (Math/pow wind-speed-20ft c))]
    {:mean m :variance (* m (sample-spotting-params normalized-distance-variance rand-gen))}))

(defn- standard-deviation
  "Returns standard deviation for the lognormal distribution given:
  mean spotting distance and it's variance"
  ^double
  [^double m ^double v]
  (Math/sqrt (Math/log (+ 1 (/ v (Math/pow m 2))))))

(defn- normalized-mean
  "Returns normalized mean for the lognormal distribution given:
  mean spotting distance and it's variance"
  ^double
  [^double m ^double v]
  (Math/log (/ (Math/pow m 2)
               (Math/sqrt (+ v (Math/pow m 2))))))

(defn- sample-normal
  "Returns sample from normal/gaussian distribution given mu and sd."
  ^double
  [^Random rand-gen ^double mu ^double sd]
  (+ mu (* sd (.nextGaussian rand-gen))))

(defn- sample-lognormal
  "Returns sample from log-normal distribution given mu and sd."
  ^double
  [^Random rand-gen ^double mu ^double sd]
  (Math/exp (sample-normal rand-gen mu sd)))

(defn- sample-wind-dir-deltas
  "Returns a sequence of [x y] distances (meters) that firebrands land away
  from a torched cell at i j where:
  x: parallel to the wind
  y: perpendicular to the wind (positive values are to the right of wind direction)"
  [{:keys [spotting rand-gen]}
   fire-line-intensity-matrix
   wind-speed-20ft [i j]]
  (let [num-firebrands          (long (sample-spotting-params (:num-firebrands spotting) rand-gen))
        intensity               (convert/Btu-ft-s->kW-m (t/mget fire-line-intensity-matrix i j))
        {:keys [mean variance]} (mean-variance spotting rand-gen intensity wind-speed-20ft)
        mu                      (normalized-mean mean variance)
        sd                      (standard-deviation mean variance)
        parallel-values         (repeatedly num-firebrands #(sample-lognormal rand-gen mu sd))
        perpendicular-values    (repeatedly num-firebrands #(sample-normal rand-gen 0.0 0.92))]
    (mapv (fn [x y] [(convert/m->ft x) (convert/m->ft y)])
          parallel-values
          perpendicular-values)))
#+end_src

Since the results are distance deltas relative to the wind direction we must
convert  this to deltas in our coordinate plane. We can convert
these deltas by using trigonometric functions.

#+name: convert-deltas
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/spotting.clj :padline no :no-expand :comments link
(defn hypotenuse ^double
  [x y]
  (Math/sqrt (+ (Math/pow x 2) (Math/pow y 2))))

(defn deltas-wind->coord
  "Converts deltas from the torched tree in the wind direction to deltas
  in the coordinate plane"
  [deltas ^double wind-direction]
  (mapv (fn [[d-paral d-perp]]
          (let [d-paral (double d-paral)
                d-perp  (double d-perp)
                H  (hypotenuse d-paral d-perp)
                t1 wind-direction
                t2 (convert/rad->deg (Math/atan (/ d-perp d-paral)))
                t3 (+ t1 t2)]
            [(* H (Math/sin (convert/deg->rad t3)))
             (* -1 H (Math/cos (convert/deg->rad t3)))]))
        deltas))

(defn firebrands
  "Returns a sequence of cells [i,j] that firebrands land in.
   Note: matrix index [i,j] refers to [row, column]. Therefore, we need to flip
   [row,column] to get to [x,y] coordinates."
  [deltas wind-towards-direction cell ^double cell-size]
  (let [step         (/ cell-size 2)
        [y x]        (mapv #(+ step (* ^double % cell-size)) cell)
        x            (double x)
        y            (double y)
        coord-deltas (deltas-wind->coord deltas wind-towards-direction)]
    (mapv (fn [[dx dy]]
            (let [dx (double dx)
                  dy (double dy)]
              [(long (Math/floor (/ (+ dy y) cell-size)))
               (long (Math/floor (/ (+ dx x) cell-size)))]))
          coord-deltas)))
#+end_src

The Spot Ignition model describes the probability of a spot ignition as well as
when the spot ignition should occur. Perryman uses the method described in
Schroeder (1969) but adjusts the result to take into account the distance a
firebrand lands from the source tree (using Albini 1979) and the number of
firebrands that land in a cell (using Stauffer 2008).


\begin{align*}
P(I)_d = P(I)exp(-\lambda_sd)
P(I)_d^{FB} = 1 - (1 - P(I)_d)^b
\end{align*}

where \lambda is a positive number representing the decay constant, d is the
firebrand's landing distance away from the source cell. $P(I)_d$ is the
probability of spot ignition taking into consideration of d. $P(I)_d^{FB}$ is
the probability of spot fire ignition taking into consideration b, the number of
firebrands landing in a cell.

#+name: firebrand-ignition-probability
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/spotting.clj :padline no :no-expand :comments link
(defn heat-of-preignition
  "Returns heat of preignition given:
   - Temperature: (Celsius)
   - Fine fuel moisture (0-1 ratio)

   Q_ig = 144.512 - 0.266*T_o - 0.00058 * (T_o)^2 - T_o * M + 18.54 * (1 - exp ( -15.1 * M ) ) + 640 * M  (eq. 10)"
  ^double
  [^double temperature ^double fine-fuel-moisture]
  (let [T_o temperature
        M   fine-fuel-moisture

        ;; heat required to reach ignition temperature
        Q_a (+ 144.512 (* -0.266 T_o) (* -0.00058 (Math/pow T_o 2.0)))

        ;; heat required to raise moisture to reach boiling point
        Q_b (* -1.0 T_o M)

        ;; Heat of desorption
        Q_c (* 18.54 (- 1.0 (Math/exp (* -15.1 M))))

        ;; Heat required to vaporize moisture
        Q_d (* 640.0 M)]
    (+ Q_a Q_b Q_c Q_d)))

(defn schroeder-ign-prob
  "Returns the probability of ignition as described in Shroeder (1969) given:
   - Temperature: (Celsius)
   - Fine fuel moisture (0-1 ratio)

   X = (400 - Q_ig) / 10
   P(I) = (0.000048 * X^4.3) / 50    (pg. 15)"
  ^double
  [^double temperature ^double fine-fuel-moisture]
  (let [Q_ig (heat-of-preignition temperature fine-fuel-moisture)
        X    (/ (- 400.0 Q_ig) 10.0)]
    (-> X
        (Math/pow 4.3)
        (* 0.000048)
        (/ 50.0)
        (Math/min 1.0)
        (Math/max 0.0))))

(defn- one-minus ^double [^double x] (- 1.0 x))

(defn spot-ignition-probability
  "Returns the probability of spot fire ignition (Perryman 2012) given:
   - Schroeder's probability of ignition [P(I)] (0-1)
   - Decay constant [lambda] (0.005)
   - Distance from the torched cell [d] (meters)
   - Number of firebrands accumulated in the cell [b]

   P(Spot Ignition) = 1 - (1 - (P(I) * exp(-lambda * d)))^b"
  ^double
  [^double ignition-probability ^double decay-constant ^double spotting-distance ^double firebrand-count]
  (-> decay-constant
      (* -1.0)
      (* spotting-distance)
      (Math/exp)
      (* ignition-probability)
      (one-minus)
      (Math/pow firebrand-count)
      (one-minus)))
#+end_src

A firebrand will cause an unburened cell to transition to a burned state if the
cell receives atleast one firebrand and the cell's probability of ignition as
calculated by the above equations is greater than a randomly generated uniform number.
Once a cell has been determined to ignite then the time until ignition is
calculated. The time until ignition is a sum of three time intervals: the amount
of time required for the firebrand to reach its maximum vertical height $t_v$,
the amount of time required for the firebrand to descend from the maximum
vertical height to the forest floor $t_g$, and the amount of time required for a
spot fire to ignite and build up to the steady-state $t_I$. Perryman assumes $t_v$
and $t_g$ to be equal and used the formula from Albini (1979) to calculate it.
$t_I$ is also assumed to be 20 min as used in McAlpine and Wakimoto (1991).

#+name: firebrands-time-of-ignition
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/spotting.clj :padline no :no-expand :comments link
(defn spot-ignition?
  [rand-gen ^double spot-ignition-probability]
  (let [random-number (my-rand-range rand-gen 0 1)]
    (> spot-ignition-probability random-number)))

(defn albini-t-max
  "Returns the time of spot ignition using (Albini 1979) in minutes given:
   - Flame length: (m) [z_F]

   a = 5.963                                                     (D33)
   b = a - 1.4                                                   (D34)
   D = 0.003
   t_c = 1
   w_F = 2.3 * (z_F)^0.5                                         (A58)
   t_o = t_c / (2 * z_F / w_F)
   z =  0.39 * D * 10^5
   t_T = t_o + 1.2 + (a / 3) * ( ( (b + (z/z_F) )/a )^3/2 - 1 )  (D43)"
  ^double
  [^double flame-length]
  (let [a     5.963                            ; constant from (D33)
        b     4.563                            ; constant from (D34)
        z-max 117.0                            ; max height given particle diameter of 0.003m
        w_F   (* 2.3 (Math/sqrt flame-length)) ; upward axial velocity at flame tip
        t_0   (/ w_F (* 2.0 flame-length))]    ; period of steady burning of tree crowns (t_c, min) normalized by 2*z_F / w_F
    (-> z-max
        (/ flame-length)
        (+ b)
        (/ a)
        (Math/pow 1.5)
        (- 1.0)
        (* (/ a 3.0))
        (+ 1.2)
        (+ t_0))))

(defn spot-ignition-time
  "Returns the time of spot ignition using (Albini 1979) and (Perryman 2012) in minutes given:
   - Global clock: (min)
   - Flame length: (m)

   t_spot = clock + (2 * t_max) + t_ss"
  ^double
  [^double global-clock ^double flame-length]
  (let [t-steady-state 20.0] ; period of building up to steady state from ignition (min)
    (-> (albini-t-max flame-length)
        (* 2.0)
        (+ global-clock)
        (+ t-steady-state))))
#+end_src

Once the locations, ignition probabilities, and time of ignition has been
calculated for each of the firebrands a sequence of key value pairs are
returned, to be processed in `gridfire.cli`. The key is [x y] location of the
firebrand and the value [t p] where t is the time of igintion and p is the
ignition probability.
#+name: spread-firebrands
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/spotting.clj :padline no :no-expand :comments link
(defn- update-firebrand-counts!
  [{:keys [num-rows num-cols fuel-model-matrix]}
   firebrand-count-matrix
   fire-spread-matrix
   source
   firebrands]
  (doseq [[x y :as here] firebrands
          :when          (and (in-bounds? num-rows num-cols [x y])
                              (burnable? fire-spread-matrix
                                         fuel-model-matrix
                                         source
                                         here))
          :let           [new-count (inc ^double (t/mget firebrand-count-matrix x y))]]
    (t/mset! firebrand-count-matrix x y new-count)))

(defn- in-range?
  [[min max] fuel-model-number]
  (<= min fuel-model-number max))

(defn surface-spot-percent
  "Returns the surface spotting probability, given:
   - A vector of vectors where the first entry is a vector range of fuel models,
     and the second entry is either a single probability or vector range of probabilities
     of those fuels spotting (e.g. `[[[10 20] 0.2]]` or `[[[10 20] [0.2 0.4]]]`)
   - The fuel model number for the particular cell
   - A random number generator, which is used to generate the probability when
     a range of probabilities is given"
  ^double
  [fuel-range-percents fuel-model-number rand-gen]
  (reduce (fn [acc [fuel-range percent]]
            (if (in-range? fuel-range fuel-model-number)
              (if (vector? percent)
                (my-rand-range rand-gen (percent 0) (percent 1))
                percent)
              acc))
          0.0
          fuel-range-percents))

(defn surface-fire-spot-fire?
  "Expects surface-fire-spotting config to be a sequence of tuples of
  ranges [lo hi] and spotting probability. The range represents the range (inclusive)
  of fuel model numbers that the spotting probability is set to.
  [[[1 140] 0.0]
  [[141 149] 1.0]
  [[150 256] 1.0]]"
  [{:keys [spotting rand-gen fuel-model-matrix]} [i j] ^double fire-line-intensity]
  (let [{:keys [surface-fire-spotting]} spotting]
    (when (and
           surface-fire-spotting
           (> fire-line-intensity ^double (:critical-fire-line-intensity surface-fire-spotting)))
      (let [fuel-range-percents (:spotting-percent surface-fire-spotting)
            fuel-model-number   (long (t/mget fuel-model-matrix i j))
            spot-percent        (surface-spot-percent fuel-range-percents fuel-model-number rand-gen)]
        (>= spot-percent (my-rand-range rand-gen 0.0 1.0))))))

(defn crown-spot-fire?
  "Determine whether crowning causes spot fires. Config key `:spotting` should
   take either a vector of probabilities (0-1) or a single spotting probability."
  [{:keys [spotting rand-gen]}]
  (when-let [spot-percent (:crown-fire-spotting-percent spotting)]
    (let [^double p (if (vector? spot-percent)
                      (let [[lo hi] spot-percent]
                        (my-rand-range rand-gen lo hi))
                      spot-percent)]
      (>= p (my-rand-range rand-gen 0.0 1.0)))))

(defn- spot-fire? [inputs crown-fire? here fire-line-intensity]
  (if crown-fire?
    (crown-spot-fire? inputs)
    (surface-fire-spot-fire? inputs here fire-line-intensity)))

(defn spread-firebrands
  "Returns a sequence of key value pairs where
  key: [x y] locations of the cell
  val: [t p] where:
  t: time of ignition
  p: ignition-probability"
  [{:keys
    [num-rows num-cols cell-size fuel-model-matrix elevation-matrix spotting rand-gen
     get-temperature get-relative-humidity get-wind-speed-20ft get-wind-from-direction
     get-fuel-moisture-dead-1hr] :as inputs}
   {:keys [firebrand-count-matrix fire-spread-matrix fire-line-intensity-matrix flame-length-matrix]}
   {:keys [cell fire-line-intensity crown-fire?]}
   global-clock]
  (when (spot-fire? inputs crown-fire? cell fire-line-intensity)
    (let [band              (long (/ global-clock 60.0))
          [i j]             cell
          tmp               (get-temperature band i j)
          rh                (get-relative-humidity band i j)
          ws                (get-wind-speed-20ft band i j)
          wd                (get-wind-from-direction band i j)
          m1                (if get-fuel-moisture-dead-1hr
                              (get-fuel-moisture-dead-1hr band i j)
                              (calc-fuel-moisture rh tmp :dead :1hr))
          deltas            (sample-wind-dir-deltas inputs
                                                    fire-line-intensity-matrix
                                                    (convert/mph->mps ws)
                                                    cell)
          wind-to-direction (mod (+ 180 wd) 360)
          firebrands        (firebrands deltas wind-to-direction cell cell-size)]
      (update-firebrand-counts! inputs firebrand-count-matrix fire-spread-matrix cell firebrands)
      (->> (for [[x y] firebrands
                 :when (and (in-bounds? num-rows num-cols [x y])
                            (burnable? fire-spread-matrix fuel-model-matrix cell [x y]))
                 :let  [fine-fuel-moisture   (double m1)
                        ignition-probability (schroeder-ign-prob (convert/F->C (double tmp)) fine-fuel-moisture)
                        decay-constant       (double (:decay-constant spotting))
                        spotting-distance    (convert/ft->m (distance-3d elevation-matrix
                                                                         (double cell-size)
                                                                         [x y]
                                                                         cell))
                        firebrand-count      (t/mget firebrand-count-matrix x y)
                        spot-ignition-p      (spot-ignition-probability ignition-probability
                                                                        decay-constant
                                                                        spotting-distance
                                                                        firebrand-count)]]
             (when (spot-ignition? rand-gen spot-ignition-p)
               (let [[i j] cell
                     t     (spot-ignition-time global-clock
                                               (convert/ft->m (t/mget flame-length-matrix i j)))]
                 [[x y] [t spot-ignition-p]])))
           (remove nil?)))))
  #+end_src

** Suppression Model Formulas

GridFire supports two ways to compute the fraction of the fire
perimeter that should be contained during a suppression event.

*** Suppression Curve

Fraction Contained (FC) is computed by

\begin{align*}
FC = (\frac{2x}{1 + x^2})^a
\end{align*}

Where symbols are defined as follows:

- $a$ :: alpha (a.k.a *:suppression-coefficient* in the config file) a
  positive number, As alpha approaches infinity, most of the
  suppression happens sharply near the end; as it approaches 0, most
  of the suppression happens sharply near the beginning. Values above
  0 make the curve sigmoid-shaped.

- $x$ :: The runtime-fraction (ratio) x at which a fraction y of the perimeter got
  suppressed is an increasing function of y^(1/alpha); in particular,
  it's an increasing function of both y and alpha.

Here are two example plots of the above equation. For most of the
regressions, the value of alpha has been between 2.0 and 3.0 as for
California and Oregon respectively.

\begin{center}
\noindent\makebox[\textwidth]{\includegraphics[width=\paperwidth]{suppression-curve-plots}}
\end{center}

*** Suppression Difficulty Index (SDI)

The SDI approach computes change in fraction contained $\Delta{C}$ during
time interval $\Delta{t}$ (in days) between suppression events.

\begin{align*}
\frac{\Delta{C}}{\Delta{t}} = \chi \times f \left( 1 - \frac{\ln(A_d / A_\chi)}{\ln(A_{d0} / A_\chi)}, B \times \text{SDI}_{\Delta{t}} \right)
\end{align*}

\begin{align*}
f(U, V) :=
\begin{cases}
U \exp(-V),& U \geq 0\\
U \exp(V),& U < 0
\end{cases}
\end{align*}

Where symbols are defined as follows:

- $A_d$ :: (ac/day) Areal growth on a daily basis.

- $A_\chi$ :: (ac/day, a.k.a *sdi-reference-areal-growth-rate* in source code)
  *reference areal-growth-rate* parameter, currently hardcoded to 1 ac/day. The
  areal-growth-rate $A_d$ at which $\frac{\Delta{C}}{\Delta{t}} = C \times \chi$
  in 0-SDI settings.

- $\chi$ :: (%/day) "Chi" (a.k.a, *:sdi-reference-suppression-speed*
  in the config file) a positive number.
  Higher means faster evolution of the fraction contained.
  $\chi^{-1}$ is a characteristic time of containment-variation.
  This calibration parameter is
  similar to the suppression curve calibration coefficient in that it
  varies regionally based on available resources.
  In a reference situation where $A_d = A_\chi$ and SDI = 0,
  a value of 100 means the fire can be 100% contained in 24 hours,
  and a value of 800 means the fire can be 100% contained in 3 hours.

- $A_{d0}$ :: (ac/day, a.k.a *:sdi-containment-overwhelming-area-growth-rate* in
  config file) *containment-overwhelming areal growth rate* parameter. For $A_d >
  A_{d0}$, the variation in containment $\Delta{C} / \Delta{t}$ becomes
  negative.

- $B$ :: ($\text{SDI}^{-1}$, a.k.a *:sdi-sensitivity-to-difficulty* in config file)
  *sensitivity to difficulty* parameter. Higher means that suppression behavior is
  more sensitive to changes in SDI. Changing the terrain's SDI by $B^{-1}$
  causes an e-folding of the containment-variation $\Delta{C} / \Delta{t}$,
  all else being equal.

$\text{SDI}_{\Delta{t}}$  is calculated as the mean suppression
difficulty index during interval $\Delta{t}$.

\begin{align*}
\overline{SDI_{\Delta{t}}} = \frac{1}{n}\times\sum_{i=1}^{n}SDI_i
\end{align*}

Where symbols are defined as follows:

- $n$ :: Number of burned pixels during time interval $\Delta{t}$.

- $i$ :: Pixel index.

- $SDI_i$ :: Suppression difficulty index of pixel i. The value of this will
  come from a SDI raster layer.

The $\left( 1 - \frac{\ln(A_d / A_\chi)}{\ln(A_{d0} / A_\chi)} \right)$ factor accounts for
the effect of fire-growth-rate on containment: fast-growing fires are harder to contain,
and very fast-growing fires ($A_d > A_{d0}$) make containment a losing battle.

The $\exp(\pm B \times \text{SDI}_{\Delta{t}})$ factor
captures the effect of the terrain's suppression-difficulty
on containment: it is a factor by which the containement-variation-speed
$\Delta{C} / \Delta{t}$ is penalized or amplified due to suppression-difficulty.

The suppression algorithm was built using the method described in
"resources/suppression_curve_algorithm.pdf".

#+name: suppression
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/suppression.clj :padline no :no-expand :comments link
(ns gridfire.suppression
  "An algorithm emulating human interventions reacting to fire spread
  by suppressing ('putting out') chosen contiguous segments of the
  fire front, typically backing and flanking fires."
  (:require [gridfire.conversion :refer [cells->acres
                                         min->day
                                         percent->dec
                                         rad->deg]]))

(set! *unchecked-math* :warn-on-boxed)

(defn- combine-average ^double
  [^double avg-old ^long count-old ^double avg-new ^long count-new]
  (if (zero? (+ count-old count-new))
    0.0
    (/ (+ (* avg-old count-old)
          (* avg-new count-new))
       (+ count-old count-new))))

(defn- remove-average ^double
  [^double avg-old ^long count-old ^double avg-to-remove ^long count-of-avg-to-remove]
  (if (zero? (- count-old count-of-avg-to-remove))
    0.0
    (/ (- (* avg-old count-old) (* avg-to-remove count-of-avg-to-remove))
       (- count-old count-of-avg-to-remove))))

(defn- compute-contiguous-slices
  "Given number of cells to suppress and a map of average directional spread
  rate data with the form: angular-slice -> [average-dsr cell-count] return a
  sorted map where each map entry:

  [[`list-of-slices` `avg-dsr`] `cell-count`]

  represents a contiguous segment of the fire front, which we locate
  by `list-of-slices`, the list of successive degree slices covering
  it; `cell-count` represents the number of active perimeter cells in
  that segment, with `cell-count` no smaller than
  `num-cells-to-suppress`, but possibly bigger.

  NOTE: This constraint may be violated if a segment is adjacent to an
  already suppressed slice, in which case the segment will be included
  in the returned map even if its `cell-count` is smaller than
  `num-cells-to-suppress`.

  Note that the returned segments will tend to overlap - think of a
  sliding window of (up to `num-cells-to-suppress`) contiguous active
  cells, rotating around the centroid: the segments returned by this
  function are regular snapshots of this window."
  [^long num-cells-to-suppress angular-slice->avg-dsr+num-cells]
  (loop [sorted-contiguous-slices (sorted-map-by (fn [[_ x1] [_ x2]]
                                                   (compare x1 x2)))
         slice-data               (into [] (seq angular-slice->avg-dsr+num-cells))
         cur-contiguous-slices    []
         cur-dsr                  0.0
         cur-count                0
         left-idx                 -1
         right-idx                0]
    (cond

      (= left-idx 0)
      sorted-contiguous-slices

      ;; Do not include already suppressed regions in the longest
      ;; contiguous slice calculation.
      (let [[_ [_ cell-count]] (nth slice-data right-idx)
            cell-count         (long cell-count)]
        (and (< cur-count num-cells-to-suppress) (zero? cell-count)))
      (let [next-right-idx (if (= right-idx (dec (count slice-data)))
                             0
                             (+ right-idx 1))]
        (recur (if (seq cur-contiguous-slices)
                 (assoc sorted-contiguous-slices [cur-contiguous-slices cur-dsr] cur-count)
                 sorted-contiguous-slices)
               slice-data
               []
               0.0
               0
               (if (< right-idx left-idx) 0 next-right-idx)
               next-right-idx))

      (< cur-count num-cells-to-suppress)
      ;; expand right
      (let [[slice [avg-dsr cell-count]] (nth slice-data right-idx)
            cell-count                   (long cell-count)]
        (recur sorted-contiguous-slices
               slice-data
               (conj cur-contiguous-slices slice)
               (combine-average cur-dsr cur-count avg-dsr cell-count)
               (+ cur-count cell-count)
               left-idx
               (if (= right-idx (dec (count slice-data)))
                 0
                 (+ right-idx 1))))

      :else
      ;; shrink left
      (let [[_ [avg-dsr cell-count]] (nth slice-data (if (= -1 left-idx) 0 left-idx))
            cell-count               (long cell-count)]
        (recur (assoc sorted-contiguous-slices [cur-contiguous-slices cur-dsr] cur-count)
               slice-data
               (subvec cur-contiguous-slices 1)
               (remove-average cur-dsr cur-count avg-dsr cell-count)
               (- cur-count cell-count)
               (long
                (cond
                  (= left-idx (dec (count slice-data))) 0
                  (= -1 left-idx)                       1
                  :else                                 (+ left-idx 1)))
               right-idx)))))

(defn- compute-sub-segment
  [angular-slice->avg-dsr+num-cells slices cells-needed]
  (let [slices                           (set slices)
        angular-slice->avg-dsr+num-cells (reduce (fn [acc [slice avg-dsr+num-cells]]
                                                   (if (contains? slices slice)
                                                     (assoc acc slice avg-dsr+num-cells)
                                                     (assoc acc slice [0.0 0.0]))) ;; Needed because the segment should not be treated as circular list
                                                 (sorted-map)
                                                 angular-slice->avg-dsr+num-cells) ;; FIXME: This seems inefficient
        contiguous-slices                (compute-contiguous-slices cells-needed angular-slice->avg-dsr+num-cells)
        [[slices _] cell-count]          (first contiguous-slices)]
    [slices cell-count]))

(defn- compute-slices-to-suppress
  "Chooses slices to be suppressed, and reports the number of suppressed cells.

  Given:
  - num-cells-to-suppress: a number of cells, the suppression objective,
  - angular-slice->avg-dsr+num-cells: a map of statistics over all angular slices,

  returns a tuple [slices-to-suppress suppressed-count], in which:
  - slices-to-suppress is the set of angular slices to suppress, chosen as a tradeoff
  between contiguity, closeness to the num-cells-to-suppress objective,
  and low average spread rate.
  - suppressed-count is the number of cells in slices-to-suppress,
  which is returned to save callers the work of re-computing it.
  Warning: it may well be that suppressed-count > num-cells-to-suppress.

  This algorithm will convert `angular-slice->avg-dsr+num-cells` to a sorted map of
  `angular-slices+avg-dsr->num-cells`, representing candidate segments for suppression.
  Using this map the algorithm will collect the sequence of angular-slices
  until we have a cell-count of at least `num-cells-to-suppress`, if possible."
  [^long num-cells-to-suppress angular-slice->avg-dsr+num-cells]
  ;; NOTE this algorithm is most likely under-optimized;
  ;; having said that, it's probably not a performance bottleneck
  ;; (suppression events are typically few and far between)
  ;; and experience has shown that we'd better make this right
  ;; before making it fast.
  ;; TODO enhance performance or rethink the overall suppression algorithm.
  (letfn [(n-cells-in-slices ^long [slices]
            (transduce (map (fn n-cells-in-slice [slice]
                              (let [[_ num-cells] (get angular-slice->avg-dsr+num-cells slice)]
                                num-cells)))
                       (completing +)
                       0
                       slices))]
    (let [angular-slices+avg-dsr->num-cells (compute-contiguous-slices num-cells-to-suppress angular-slice->avg-dsr+num-cells)]
      (loop [remaining-segments angular-slices+avg-dsr->num-cells
             n-cells-needed     num-cells-to-suppress
             slices-to-suppress #{}]
        (if-some [segment (when (pos? n-cells-needed)
                            (first remaining-segments))]
          (let [[[slices _]]            segment
                yet-unsuppressed-slices (remove slices-to-suppress slices)
                n-would-be-suppressed   (long (n-cells-in-slices yet-unsuppressed-slices))]
            (if (<= n-would-be-suppressed n-cells-needed)
              (let [new-n-cells-needed     (- n-cells-needed n-would-be-suppressed)
                    new-slices-to-suppress (into slices-to-suppress yet-unsuppressed-slices)]
                (recur (rest remaining-segments)
                       new-n-cells-needed
                       new-slices-to-suppress))
              ;; this segment has more than we need, compute subsegment:
              (let [[sub-segment-slices _] (compute-sub-segment angular-slice->avg-dsr+num-cells slices n-cells-needed)
                    n-more-suppressed      (long (n-cells-in-slices (remove slices-to-suppress sub-segment-slices)))
                    new-n-cells-needed     (- n-cells-needed n-more-suppressed)
                    new-slices-to-suppress (into slices-to-suppress sub-segment-slices)]
                (recur (rest remaining-segments)
                       new-n-cells-needed
                       new-slices-to-suppress))))
          ;; no more segments needed or available, so we return:
          (let [n-suppressed (- num-cells-to-suppress n-cells-needed)]
            [slices-to-suppress n-suppressed]))))))

(defn- average
  [coll]
  (/ (double (reduce + coll)) (long (count coll))))

(defn- compute-avg-dsr
  [burn-vectors]
  (-> (reduce (fn ^double [^double acc burn-vector]
                (+ acc (double (:spread-rate burn-vector))))
              0.0
              burn-vectors)
      double
      (/ (count burn-vectors))))

(defn- compute-cell-count
  [burn-vectors]
  (count
   (into #{}
         (map (juxt :i :j))
         burn-vectors)))

(defn- compute-avg-dsr-data
  "Returns a sorted map where each map entry:

  [`angular-slice` [`directional-spread-rate` `cell-count`]]

  represents a collection of stats computed for an `angular-slice`. The
  `directional-spread-rate` is the average value among the active
  perimeter cells that fall within that slice. The `cell-count` is the
  count of those perimeter cells."
  [^double angular-slice-size slice->BurnVectors]
  (reduce (fn [acc slice]
            (let [burn-vectors (get slice->BurnVectors slice)]
              (if (seq burn-vectors)
                (assoc acc slice [(compute-avg-dsr burn-vectors) (compute-cell-count burn-vectors)])
                (assoc acc slice [0.0 0.0]))))
          (sorted-map)
          (range 0.0 (/ 360.0 angular-slice-size))))

(defn- angle-cw-from-east ^double
  [^long i1 ^long j1 ^long i0 ^long j0]
  (let [di    (- i1 i0)
        dj    (- j1 j0)
        theta (rad->deg (Math/atan2 di dj))]
    (if (neg? di)
      (+ theta 360.0)
      theta)))

(defn- nearest-angular-slice ^double
  [^double theta ^double angular-slice-size]
  (Math/floor (/ theta angular-slice-size)))

(defn- group-burn-vectors
  "Returns a map where each entry:

  [`angular-slice` [BurnVector BurnVector ...]]

  represents a collection of BurnVectors that fall within an `angular-slice`.
  The `angular-slice` is defined as the degree clockwise from EAST of the
  `centroid` cell. angular-slice 0 = East = 0.0 degrees."
  [centroid ^double angular-slice-size burn-vectors]
  (let [[i0 j0] centroid]
    (group-by (fn [burn-vector] (-> (angle-cw-from-east (:i burn-vector) (:j burn-vector) i0 j0)
                                    (nearest-angular-slice angular-slice-size)))
              burn-vectors)))

(defn- compute-centroid-cell
  "Returns [i j] that is the centroid of a given list of [i j] cells"
  [cells]
  (let [row (average (mapv #(nth % 0) cells))
        col (average (mapv #(nth % 1) cells))]
    [(long row) (long col)]))

(defn- compute-suppression-difficulty-factor ^double
  [^double sdi-sensitivity-to-difficulty ^double change-in-fraction-contained-sign-multiplier ^double mean-sdi]
  (double
   (if (>= change-in-fraction-contained-sign-multiplier 0.0)
     (Math/exp (* -1.0 sdi-sensitivity-to-difficulty mean-sdi))
     (Math/exp (* sdi-sensitivity-to-difficulty mean-sdi)))))

(defn- compute-mean-sdi ^double
  [get-suppression-difficulty-index ignited-cells]
  (/ (double
      (reduce (fn ^double [^double acc [i j]]
                (+ acc (double (get-suppression-difficulty-index i j))))
              0.0
              ignited-cells))
     (count ignited-cells)))

(defn- compute-area-growth-rate ^double
  [^double cell-size ^double suppression-dt ignited-cells-since-last-suppression]
  (/ (cells->acres cell-size (count ignited-cells-since-last-suppression))
     (min->day suppression-dt)))

(def ^:const sdi-reference-areal-growth-rate
  "[ac/day] a shape parameter for the suppression curve, the area-growth-rate A_d at which ÎC/Ît=Ï in 0-SDI settings,
  in which Ï is the :sdi-reference-suppression-speed parameter."
  1.0)

(defn- compute-change-in-fraction-contained-sign-multiplier ^double
  [^double sdi-containment-overwhelming-area-growth-rate ^double area-growth-rate]
  (- 1.0
     ;; Note that the following ratio is insensitive to the choice of logarithm base.
     (/ (Math/log (/ area-growth-rate
                     sdi-reference-areal-growth-rate))
        (Math/log (/ sdi-containment-overwhelming-area-growth-rate
                     sdi-reference-areal-growth-rate)))))

(defn- compute-fraction-contained-sdi
  "Compute the updated fraction contained using suppression difficulty index algorithm"
  [inputs ignited-cells-since-last-suppression ^double previous-fraction-contained]
  (let [cell-size                                     (double (:cell-size inputs))
        get-suppression-difficulty-index              (:get-suppression-difficulty-index inputs)
        suppression-dt                                (double (:suppression-dt inputs))
        sdi-containment-overwhelming-area-growth-rate (double (:sdi-containment-overwhelming-area-growth-rate inputs))
        sdi-sensitivity-to-difficulty                 (double (:sdi-sensitivity-to-difficulty inputs))
        sdi-reference-suppression-speed               (double (:sdi-reference-suppression-speed inputs))
        area-growth-rate                              (compute-area-growth-rate cell-size suppression-dt ignited-cells-since-last-suppression)
        change-in-fraction-contained-sign-multiplier  (compute-change-in-fraction-contained-sign-multiplier sdi-containment-overwhelming-area-growth-rate
                                                                                                            area-growth-rate)
        mean-sdi                                      (compute-mean-sdi get-suppression-difficulty-index ignited-cells-since-last-suppression)
        suppression-difficulty-factor                 (compute-suppression-difficulty-factor sdi-sensitivity-to-difficulty
                                                                                             change-in-fraction-contained-sign-multiplier
                                                                                             mean-sdi)
        change-in-fraction-contained                  (-> (* sdi-reference-suppression-speed
                                                             change-in-fraction-contained-sign-multiplier
                                                             suppression-difficulty-factor)
                                                          (percent->dec)
                                                          (* (min->day suppression-dt)))]
    (+ previous-fraction-contained change-in-fraction-contained)))

(defn- compute-fraction-contained-sc
  "Compute fraction contained using suppression curve algorithm"
  ^double
  [^double max-runtime-fraction ^double suppression-coefficient]
  (Math/pow (/ (* 2.0 max-runtime-fraction)
               (+ 1.0 (Math/pow max-runtime-fraction 2.0)))
            suppression-coefficient))

(defn suppress-burn-vectors
  [inputs
   max-runtime-fraction
   previous-num-perimeter-cells
   previous-suppressed-count
   burn-vectors
   ignited-cells-since-last-suppression
   previous-fraction-contained]
  (let [max-runtime-fraction         (double max-runtime-fraction)
        suppression-coefficient      (:suppression-coefficient inputs)
        previous-num-perimeter-cells (long previous-num-perimeter-cells)
        previous-suppressed-count    (long previous-suppressed-count)
        active-perimeter-cells       (into #{}
                                           (map (juxt :i :j))
                                           burn-vectors)
        fraction-contained           (if suppression-coefficient
                                       (compute-fraction-contained-sc max-runtime-fraction
                                                                      (double suppression-coefficient))
                                       (compute-fraction-contained-sdi inputs
                                                                       ignited-cells-since-last-suppression
                                                                       previous-fraction-contained))
        num-tracked-perimeter-cells  (+ (long (count active-perimeter-cells)) previous-suppressed-count)
        num-fizzled-perimeter-cells  (max 0 (- previous-num-perimeter-cells num-tracked-perimeter-cells))
        num-perimeter-cells          (max previous-num-perimeter-cells num-tracked-perimeter-cells)
        current-suppressed-count     (+ previous-suppressed-count num-fizzled-perimeter-cells)
        next-suppressed-count        (long (* ^double fraction-contained num-perimeter-cells))
        num-cells-to-suppress        (- next-suppressed-count current-suppressed-count)]
    (if (> num-cells-to-suppress 0)
      (let [centroid-cell          (compute-centroid-cell active-perimeter-cells)
            angular-slice-size     5.0
            slice->BurnVectors     (group-burn-vectors centroid-cell angular-slice-size burn-vectors)
            [slices-to-suppress
             suppressed-count]     (->> (compute-avg-dsr-data angular-slice-size slice->BurnVectors)
                                        (compute-slices-to-suppress num-cells-to-suppress))
            slices-to-suppress-set (set slices-to-suppress)
            slices-to-keep         (remove #(contains? slices-to-suppress-set %) (keys slice->BurnVectors))
            burn-vectors-to-keep   (into []
                                         (mapcat #(get slice->BurnVectors %))
                                         slices-to-keep)]
        [burn-vectors-to-keep (+ current-suppressed-count ^long suppressed-count) num-perimeter-cells fraction-contained])
      [burn-vectors current-suppressed-count num-perimeter-cells fraction-contained])))
#+end_src

* User Interface

The GridFire model described in the previous section may be called
directly from the REPL through the *run-fire-spread* function.
However, this would require that the user had already prepared all of
their map layers as 2D Clojure core.matrix values. In order to enable
GridFire to easily access a wide range of raster formatted GIS layers
directly, we have the following options:

1. A simple Clojure interface to a Postgresql database, containing
   the PostGIS spatial extensions. This interface is described in
   Section [[PostGIS Bridge]].

2. Magellan, a Clojure library for interacting with geospatial
   datasets. This interface is described in Section [[Magellan]].

Section [[Command Line Interface]] describes GridFire's command line
interface along with its input configuration file format, which
allows users to select between the PostGIS and Magellan data import
options easily.

Using one of these options along with a simple client interface in
clojure Section [[Command Line Interface]] which describes GridFire's
command line interface along with its input configuration file format.

** PostGIS Bridge

Extracting raster layers from a PostGIS database is performed by a
single function, called *postgis-raster-to-matrix*, which constructs a
SQL query for the layer, sends it to the database in a transaction,
and returns the result as a core.matrix 2D double array with nodata
values represented as -1.0. The georeferencing information associated
with this tile is also included in the returned results. This function
may be called directly from the REPL or indirectly through GridFire's
command line interface.

#+name: postgis-bridge
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/postgis_bridge.clj :padline no :no-expand :comments link
(ns gridfire.postgis-bridge
  (:require [clojure.java.jdbc :as jdbc]
            [hikari-cp.core    :as h]
            [tech.v3.datatype  :as d]
            [tech.v3.tensor    :as t])
  (:import java.util.UUID
           org.postgresql.jdbc.PgArray))

(set! *unchecked-math* :warn-on-boxed)

(defn extract-matrix [result]
  (->> result
       :matrix
       (#(.getArray ^PgArray %)) ; Note: I can pass a HashMap of {String,Class}
       t/->tensor                ; to automatically convert SQL types to Java types.
       (d/emap #(or % -1.0) nil) ; FIXME: is this step necessary?
       d/clone))                 ; What happens to null values when read?

(defn build-rescale-query [rescaled-table-name resolution table-name]
  (format (str "CREATE TEMPORARY TABLE %s "
               "ON COMMIT DROP AS "
               "SELECT ST_Rescale(rast,%s,-%s,'NearestNeighbor') AS rast "
               "FROM %s")
          rescaled-table-name
          resolution
          resolution
          table-name))

(defn build-threshold-query [threshold]
  (format (str "ST_MapAlgebra(rast,band,NULL,"
               "'CASE WHEN [rast.val] < %s"
               " THEN 0.0 ELSE [rast.val] END')")
          threshold))

(defn build-data-query [threshold threshold-query metadata table-name]
  (format (str "SELECT ST_DumpValues(%s,%s) AS matrix "
               "FROM generate_series(1,%s) AS band "
               "CROSS JOIN %s")
          (if threshold threshold-query "rast")
          (if threshold 1 "band")
          (:numbands metadata)
          table-name))

(defn build-meta-query [table-name]
  (format "SELECT (ST_Metadata(rast)).* FROM %s" table-name))

(defn- parse-subname [subname]
  {:database (re-find #"(?<=\/)[\w]*$" subname)
   :port     (re-find #"(?<=:)[0-9]*[0-9](?=\/)" subname)
   :server   (re-find #"(?<=\/)[\w]*(?=:)" subname)})

(defn build-datasource-options [{:keys [user password subname]}]
  (let [{:keys [database port server]} (parse-subname subname)]
      {:auto-commit        true
       :read-only          false
       :connection-timeout 30000
       :validation-timeout 5000
       :idle-timeout       600000
       :max-lifetime       1800000
       :minimum-idle       10
       :maximum-pool-size  10
       :pool-name          "db-pool"
       :adapter            "postgresql"
       :username           user
       :password           password
       :database-name      database
       :server-name        server
       :port-number        port
       :register-mbeans    false}))

(defonce db-pool-cache (atom nil))

(defn make-db-pool [db-spec]
  (or @db-pool-cache
      (reset! db-pool-cache (h/make-datasource (build-datasource-options db-spec)))))

(defn close-db-pool []
  (h/close-datasource @db-pool-cache)
  (reset! db-pool-cache nil))

(defmacro with-db-connection-pool [db-spec & body]
  `(if-let [db-spec# ~db-spec]
     (let [_#      (make-db-pool db-spec#)
           result# (do ~@body)]
       (close-db-pool)
       result#)
     (do ~@body)))

(defn postgis-raster-to-matrix
  "Send a SQL query to the PostGIS database given by db-spec for a
  raster tile from table table-name. Optionally resample the raster to
  match resolution and set any values below threshold to 0. Return the
  post-processed raster values as a Clojure matrix using the
  core.matrix API along with all of the georeferencing information
  associated with this tile in a hash-map with the following form:
  {:srid 900916,
   :upperleftx -321043.875,
   :upperlefty -1917341.5,
   :width 486,
   :height 534,
   :scalex 2000.0,
   :scaley -2000.0,
   :skewx 0.0,
   :skewy 0.0,
   :numbands 10,
   :matrix #vectorz/matrix Large matrix with shape: [10,534,486]}"
  [db-spec table-name & [resolution threshold]]
  (jdbc/with-db-transaction [conn {:datasource (make-db-pool db-spec)}]
    (let [table-name      (if-not resolution
                            table-name
                            (let [rescaled-table-name (str "gridfire_" (subs (str (UUID/randomUUID)) 0 8))
                                  rescale-query       (build-rescale-query rescaled-table-name resolution table-name)]
                              ;; Create a temporary table to hold the rescaled raster.
                              ;; It will be dropped when the transaction completes.
                              (jdbc/db-do-commands conn [rescale-query])
                              rescaled-table-name))
          meta-query      (build-meta-query table-name)
          metadata        (first (jdbc/query conn [meta-query]))
          threshold-query (build-threshold-query threshold)
          data-query      (build-data-query threshold threshold-query metadata table-name)
          matrix          (when-let [results (seq (jdbc/query conn [data-query]))]
                            (if (= (count results) 1)
                              (extract-matrix (first results))
                              (t/->tensor (mapv extract-matrix results))))]
      (assoc metadata :matrix matrix))))
#+end_src

** Magellan

Reading raster layers from disk is performed by a single function,
called *geotiff-raster-to-tensor*. Given the location of a GeoTIFF
file, this function will read the raster into memory and return the
same map of information as the *postgis-raster-to-matrix* function,
described in the previous section.

#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/magellan_bridge.clj :padline no :no-expand :comments link
(ns gridfire.magellan-bridge
  (:require [clojure.java.io         :as io]
            [magellan.core           :refer [read-raster register-new-crs-definitions-from-properties-file!]]
            [magellan.raster.inspect :as inspect]
            [tech.v3.tensor          :as t])
  (:import org.geotools.coverage.grid.GridGeometry2D
           org.geotools.referencing.operation.transform.AffineTransform2D))

(set! *unchecked-math* :warn-on-boxed)

(defn register-custom-projections! []
  (register-new-crs-definitions-from-properties-file! "CUSTOM" (io/resource "custom_projections.properties")))

(defn geotiff-raster-to-tensor
  "Reads a raster from a file using the magellan.core library. Returns the
   post-processed raster values as a Clojure tensor using the dtype-next/tech.v3.tensor API
   along with all of the georeferencing information associated with this tile in a
   hash-map with the following form:
  {:srid 900916,
   :upperleftx -321043.875,
   :upperlefty -1917341.5,
   :width 486,
   :height 534,
   :scalex 2000.0,
   :scaley -2000.0,
   :skewx 0.0,
   :skewy 0.0,
   :numbands 10,
   :matrix #tech.v3.tensor<datatype>[10 534 486]}"
  [file-path & [datatype convert-fn]]
  (let [raster   (read-raster file-path)
        grid     ^GridGeometry2D (:grid raster)
        r-info   (inspect/describe-raster raster)
        image    (:image r-info)
        envelope (:envelope r-info)
        crs2d    ^AffineTransform2D (.getGridToCRS2D grid)]
    {:srid       (:srid r-info)
     :upperleftx (get-in envelope [:x :min])
     :upperlefty (get-in envelope [:y :max])
     :width      (:width image)
     :height     (:height image)
     :scalex     (.getScaleX crs2d)
     :scaley     (.getScaleY crs2d)
     :skewx      0.0 ; FIXME not used?
     :skewy      0.0 ; FIXME not used?
     :numbands   (:bands image)
     :matrix     (inspect/extract-tensor raster :datatype datatype :convert-fn convert-fn)}))
#+end_src

** Command Line Interface

The entire GridFire system is available for use directly from the
Clojure REPL. This enables straightforward analysis and introspection
of the fire behavior functions and their results over a range of
inputs. However, if you just want to simulate an individual
ignition event, GridFire comes with a simple command line interface
that can be parameterized by a single configuration file, specifying
the ignition location, burn duration, weather values, and the location
of the PostGIS raster layers to use for topography and fuels.

GridFire's command line interface can be built as an uberjar using the
following command:

#+name: build-jar
#+begin_src sh :results silent :exports code
clojure -X:make-uberjar
#+end_src

The advantage of the uberjar format is that the single uberjar file
can be shared easily between computers and can be run by anyone with a
recent version of Java installed, without needing to install Clojure,
Git, or any of the dependency libraries that GridFire uses.

The command above will output the uberjar into this repository's top
level ``target'' directory. It can be run from the command line as
follows:

#+name: run-gridfire-jar
#+begin_src sh :results silent :exports code
java -jar gridfire.jar myconfig.edn
#+end_src

When run, the executable connects to the PostGIS database specified in
the passed-in config file, downloads the necessary raster layers,
simulates the ignition event for the requested duration, and returns
2D maps showing the spatial distributions of fire spread, flame
length, and fire line intensity respectively. Finally, it prints out
the final clock time from when the simulation was terminated as well
as the total number of ignited cells on the raster grid at that point.

Which maps are created (and in what formats) may be configured by
setting the following options in GridFire's input config file to true
or false:

#+ATTR_LATEX: :options \setlength{\itemsep}{-3mm}
1. :output-landfire-inputs?
2. :output-geotiffs?
3. :output-pngs?

#+name: gridfire-core
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/core.clj :padline no :no-expand :comments link
(ns gridfire.core
  (:require [clojure.core.reducers        :as r]
            [clojure.edn                  :as edn]
            [clojure.spec.alpha           :as spec]
            [gridfire.fire-spread-optimal :refer [rothermel-fast-wrapper-optimal]]
            [gridfire.inputs              :as inputs]
            [gridfire.outputs             :as outputs]
            [gridfire.simulations         :as simulations]
            [gridfire.spec.config         :as config-spec]
            [manifold.deferred            :as mfd]
            [taoensso.tufte               :as tufte]
            [triangulum.logging           :refer [log log-str]]))

(set! *unchecked-math* :warn-on-boxed)

(defn write-outputs!
  [outputs]
  (->
    (mfd/zip
      (outputs/write-landfire-layers! outputs)
      (outputs/write-aggregate-layers! outputs)
      (outputs/write-csv-outputs! outputs))
    (deref))
  :success)

(defmacro with-multithread-profiling
  [& body]
  `(do (tufte/remove-handler! :accumulating)
       (let [stats-accumulator# (tufte/add-accumulating-handler! {:handler-id :accumulating})
             result#            (do ~@body)]
         (Thread/sleep 1000)
         (as-> {:format-pstats-opts {:columns [:n-calls :min :max :mean :mad :clock :total]}} $#
           (tufte/format-grouped-pstats @stats-accumulator# $#)
           (log $# :truncate? false))
         result#)))

(defn run-simulations!
  [{:keys [^long simulations parallel-strategy] :as inputs}]
  (with-multithread-profiling ; TODO: Disable this to see how much performance is gained.
    (log-str "Running simulations")
    (let [parallel-bin-size 1
          reducer-fn        (if (= parallel-strategy :between-fires)
                              #(into [] (r/fold parallel-bin-size r/cat r/append! %))
                              #(into [] %))
          summary-stats     (with-redefs [rothermel-fast-wrapper-optimal (memoize rothermel-fast-wrapper-optimal)]
                              (->> (range simulations)
                                   (vec)
                                   (r/map #(simulations/run-simulation! % inputs))
                                   (r/remove nil?)
                                   (reducer-fn)))]
      (assoc inputs :summary-stats summary-stats))))

(defn load-inputs!
  [config]
  (-> config
      (inputs/add-input-layers)
      (inputs/add-misc-params)
      (inputs/add-ignition-csv)
      (inputs/add-sampled-params)
      (inputs/add-perturbation-params)
      (inputs/add-weather-params)
      (inputs/add-fuel-moisture-params)
      (inputs/add-random-ignition-sites)
      (inputs/add-aggregate-matrices)
      (inputs/add-burn-period-params)
      (inputs/add-ignition-start-times)
      (inputs/add-ignition-start-timestamps)
      (inputs/add-suppression)
      (inputs/add-spread-rate-adjustment-factors)))

(defn load-config-or-throw!
  [config-file-path]
  (let [config (files/read-situated-edn-file config-file-path)]
    (if (spec/valid? ::config-spec/config config)
      (assoc config :config-file-path config-file-path)
      (throw (ex-info (format "Invalid config file [%s]:\n%s"
                              config-file-path
                              (spec/explain-str ::config-spec/config config))
                      {::config config
                       ::spec-explanation (spec/explain-data ::config-spec/config config)})))))

(defn load-config!
  [config-file-path]
  (try
    (load-config-or-throw! config-file-path)
    (catch Exception err
      (log-str (ex-message err)))))

(defn process-config-file!
  [config-file-path]
  (try
    (some-> config-file-path
            (load-config!)
            (load-inputs!)
            (run-simulations!)
            (write-outputs!))
    (catch Exception e
      (log-str (ex-message e)))))
#+end_src

#+name: command-line-interface
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/cli.clj :padline no :no-expand :comments link
(ns gridfire.cli
  (:gen-class)
  (:require [clojure.core.async       :refer [<!!]]
            [clojure.edn              :as edn]
            [clojure.java.io          :as io]
            [clojure.tools.cli        :refer [parse-opts]]
            [gridfire.core            :as gridfire]
            [gridfire.magellan-bridge :refer [register-custom-projections!]]
            [gridfire.server          :as server]
            [gridfire.utils.server    :refer [hostname? nil-on-error]]))

(set! *unchecked-math* :warn-on-boxed)

(def cli-options
  [["-c" "--server-config CONFIG" "Server config file"
    :validate [#(.exists  (io/file %)) "The provided --server-config does not exist."
               #(.canRead (io/file %)) "The provided --server-config is not readable."]]

   ["-h" "--host HOST" "Host domain name"
    :validate [hostname? "The provided --host is invalid."]]

   ["-p" "--port PORT" "Port number"
    :parse-fn #(if (int? %) % (Integer/parseInt %))
    :validate [#(< 0 % 0x10000) "The provided --port is not a number between 0 and 65536."]]])

(def program-banner
  (str "gridfire: Launch fire spread simulations via config files or in server mode.\n"
       "Copyright Â© 2014-2022 Spatial Informatics Group, LLC.\n"))

(defn -main [& args]
  (println program-banner)
  (let [{:keys [options arguments summary errors]} (parse-opts args cli-options)]
    ;; {:options   The options map, keyed by :id, mapped to the parsed value
    ;;  :arguments A vector of unprocessed arguments
    ;;  :summary   A string containing a minimal options summary
    ;;  :errors    A vector of error message strings thrown during parsing; nil when no errors exist
    (cond
      ;; Errors encountered during input parsing
      (seq errors)
      (do
        (run! println errors)
        (println (str "\nUsage:\n" summary))
        (System/exit 1))

      ;; Server mode invoked
      (every? options [:server-config :host :port])
      (if-let [config-file-params (nil-on-error (edn/read-string (slurp (:server-config options))))]
        (do
          (register-custom-projections!)
          (<!! (server/start-server! (merge config-file-params (dissoc options :server-config)))))
        (do
          (println (:server-config options) "does not contain well-formed EDN.")
          (println (str "\nUsage:\n" summary))
          (System/exit 1)))

      ;; CLI mode invoked
      (seq arguments)
      (do
        (register-custom-projections!)
        (doseq [config-file arguments]
          (gridfire/process-config-file! config-file)))

      ;; Incorrect CLI invocation
      :else
      (do
        (println "For gridfire cli mode, include one or more gridfire.edn files.")
        (println "For gridfire server mode, include these args: --server-config --host --port")
        (println (str "\nUsage:\n" summary))))

    ;; Exit cleanly
    (System/exit 0)))
#+end_src

#+name: utils-random
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/utils/random.clj :padline no :no-expand :comments link
(ns gridfire.utils.random
  (:import (java.util ArrayList Collection Collections Random)))

(defn my-rand
  (^double [^Random rand-generator] (.nextDouble rand-generator))
  (^double [^Random rand-generator n] (* n (.nextDouble rand-generator))))

(defn my-rand-int
  ^long
  [rand-generator n]
  (long (my-rand rand-generator n)))

(defn my-rand-nth
  [rand-generator coll]
  (nth coll (my-rand-int rand-generator (count coll))))

(defn my-rand-range
  ^double
  [rand-generator min-val max-val]
  (let [range (- max-val min-val)]
    (+ min-val (my-rand rand-generator range))))

(defn- sample-from-list
  [rand-generator n xs]
  (repeatedly n #(my-rand-nth rand-generator xs)))

(defn- sample-from-range
  [rand-generator n min-val max-val]
  (repeatedly n #(my-rand-range rand-generator min-val max-val)))

(defn draw-samples
  [rand-generator n x]
  (into []
        (cond (list? x)   (sample-from-list rand-generator n x)
              (vector? x) (sample-from-range rand-generator n (x 0) (x 1))
              :else       (repeat n x))))

(defn my-shuffle
  [^Random rand-gen ^Collection coll]
  (if (< (count coll) 2)
    (if (vector? coll)
      coll
      (vec coll))
    (let [al (ArrayList. coll)]
      (Collections/shuffle al rand-gen)
      (vec (.toArray al)))))
#+end_src

** Server Interface

The GridFire system is also available for use in server mode. The
GridFire server will listen for requests to launch fire sparead
simulations. Upon completion of the simulation a set of post
processing scripts will run to process binary outputs into a directory
structure containing geoTIFF files and then packed into a tarball.
This tarball is sent over scp into another server for processing.

*** Preprocessing Dependencies

The processing of active fire and match drop runs require the following package to work:

- babashka

*** Postprocessing Dependencies

The Post processing scripts require the following packages to work:

- ssh
- pigz
- mpirun
- gdal
- elmfire_post_<elmfire_version> (for elmfire version see
  `resources/elmfire_post.sh`)

*** Server Configuration

The GridFire system is also available for use in server mode. The
server is confgured by and edn file containing the following contents:

#+begin_src clojure :results silent :exports code :tangle ../resources/sample_server.edn :padline no :no-expand :comments link
{:software-dir    "/gridfire/software"
 :incoming-dir    "/gridfire/incoming"
 :active-fire-dir "/gridfire/incoming/active_fires"
 :data-dir        "/gridfire/data"
 :log-dir         "/gridfire/log"}
#+end_src

- software-dir :: The directory the gridfire repo is cloned into.

- incoming-dir :: The directory where the server will look for
  match-drop input decks (which should be uploaded from the data
  provisioning server on wx.pyregence.org). The server keeps the
  latest 20 input decks. (see cleanup.sh in this directory)

- active-fire-dir :: The directory where the server will look for
  active-fire input decks (which are uploaded from the data
  provisioning server on wx.pyregence.org). The server's file watcher
  thread will automatically add a request onto the server's
  `standby-queue` whenever a new input deck is uploaded. The server
  keeps the latest 200 input decks. (see cleanup.sh in this
  directory)

- data-dir :: The directory into which input deck tarballs from
  incoming-dir are unpacked. The server keeps the latest 20 unpacked
  tarballs. (see cleanup.sh in this directory)

- log-dir :: The directory into which log files are written. The server
  keeps the last 10 days of logs.

The GridFire server is launched by user `gridfire` with this command:

#+begin_src sh
clojure -M:run-server -c server.edn
#+end_src

* Configuration File

The configuration file for GridFire's command line interface is a text
file in Extensible Data Notation (EDN)
format.[fn::https://github.com/edn-format/edn] A sample configuration
file is provided below and in ``resources/sample_config.edn''. The
format should be self-evident at a glance, but it is worth noting that
EDN is case-sensitive but whitespace-insensitive. Comments are
anything following two semi-colons (;;). Strings are contained in
double-quotes (``''). Keywords are prefixed with a colon (:). Vectors
are delimited with square brackets ([]). Associative lookup tables
(a.k.a. maps) are delimited with curly braces ({}) and are used to
express key-value relationships.

The configuration file can be broken up into 5 sections as described
below:

** Section 1: Landscape data to be shared by all simulations

GridFire allows us to choose how we want to ingest landscape data
through the configuration file. We can choose to get LANDFIRE layers
from our PostGIS database, or we can read raster files from disk. This
behavior is controlled as follows:

Include the following mapping at the top level of the configuraiton
file:

- *landfire-layers*: a map of fetch specifications

For the fetch specifications include the following mappings:
- *type*: the method for fetching the layer
- *source*: the string input for the fetch method

To fetch layers from a Postgresql database you must also include the
follwing mapping:

- *db-spec*: a map of database connection information for our Postgresql
  database

Here's an example of fetching LANDFIRE layers from a Postgresql database.
#+begin_src clojure
{:db-spec            {:classname   "org.postgresql.Driver"
                      :subprotocol "postgresql"
                      :subname     "//localhost:5432/gridfire"
                      :user        "gridfire"}
 :landfire-layers    {:aspect             {:type   :postgis
                                           :source "landfire.asp WHERE rid=100"}
                      :canopy-base-height {:type   :postgis
                                           :source "landfire.cbh WHERE rid=100"}
                      :canopy-cover       {:type   :postgis
                                           :source "landfire.cc WHERE rid=100"}
                      :canopy-height      {:type   :postgis
                                           :source "landfire.ch WHERE rid=100"}
                      :crown-bulk-density {:type   :postgis
                                           :source "landfire.cbd WHERE rid=100"}
                      :elevation          {:type   :postgis
                                           :source "landfire.fbfm40 WHERE rid=100"}
                      :fuel-model         {:type   :postgis
                                           :source "landfire.slp WHERE rid=100"}
                      :slope              {:type   :postgis
                                           :source "landfire.dem WHERE rid=100"}}}
#+end_src

Here's an example of fetching LANDFIRE layers from files on disk using
relative paths to where the gridfire.edn resides.
#+begin_src clojure
{:landfire-layers {:aspect             {:type   :geotiff
                                        :source #gridfire.utils.files/from-this-file "./asp.tif"}
                   :canopy-base-height {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./cbh.tif"}
                   :canopy-cover       {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./cc.tif"}
                   :canopy-height      {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./ch.tif"}
                   :crown-bulk-density {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./cbd.tif"}
                   :elevation          {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./dem.tif"}
                   :fuel-model         {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./fbfm40.tif"}
                   :slope              {:type   :geotiff
                                        :source #gridfire.utils.files/fromj-this-file "./slp.tif"}}}
#+end_src

Here's an example of fetching LANDFIRE layers from files on disk using
full file paths.
#+begin_src clojure
{:landfire-layers {:aspect             {:type   :geotiff
                                        :source "test/gridfire/resources/asp.tif"}
                   :canopy-base-height {:type   :geotiff
                                        :source "test/gridfire/resources/cbh.tif"}
                   :canopy-cover       {:type   :geotiff
                                        :source "test/gridfire/resources/cc.tif"}
                   :canopy-height      {:type   :geotiff
                                        :source "test/gridfire/resources/ch.tif"}
                   :crown-bulk-density {:type   :geotiff
                                        :source "test/gridfire/resources/cbd.tif"}
                   :elevation          {:type   :geotiff
                                        :source "test/gridfire/resources/dem.tif"}
                   :fuel-model         {:type   :geotiff
                                        :source "test/gridfire/resources/fbfm40.tif"}
                   :slope              {:type   :geotiff
                                        :source "test/gridfire/resources/slp.tif"}}}
#+end_src

Gridfire uses imperial units for its calculations. Gridfire optionally
allows us to use LANDFIRE LAYERS in different units and scale.

To specify the need for conversion from metric to imperial, include
the following mapping in the fetch specifications:

- *units*: keyword :metric

#+begin_src clojure
{:canopy-height {:type   :geotiff
                 :source "test/gridfire/resources/weather-test/ch.tif"
                 :units  :metric}}
#+end_src

To specify a scaling factor, include the following mapping in the
fetch specifications:

- *multiplier*: int or float

#+begin_src clojure
{:canopy-height {:type       :geotiff
                 :source     "test/gridfire/resources/weather-test/ch.tif"
                 :multiplier 0.1}}
#+end_src

In the example above the input raster's units are meters *
10.[fn::https://landfire.gov/faqprint.php] Thus a value of 5 on the
canopy height grid layer is actually 0.5 meters. The mutipler factor
needed to convert to meters is 0.1.

Include the following required mapping on all configurations:

#+begin_src clojure
{:srid      "CUSTOM:900914"
 :cell-size 98.425} ; (feet)
#+end_src

** Section 2: Ignition data from which to build simulation inputs

GridFire allows us to choose how we want to initialize the ignition
area. We can choose one of 2 options: to initialize a single point or
an existing burn perimeter (raster).

To initialize a single point, include the following mappings:

- *ignition-row*: (single, list, or range of values)
- *ignition-col*: (single, list, or range of values)

For this method of ignition, values may be entered in one of three ways:

1. If a single value is provided, it will be kept the same for all
   simulations.
2. For a list of values, a value from the list will be randomly
   selected in each simulation.
3. For a range of values, a value from the range [inclusive exclusive]
   will be randomly selected in each simulation.

#+begin_src clojure
{:ignition-row [10 90]
 :ignition-col [20 80]}
#+end_src

Another way we can ignite a single point is to omit the keys
*ignition-row* and *ignition-col*. With this method, we can optionally
constrain the ignition location by an ignition-mask raster and/or an
edge-buffer. For specifiying these constraints include these optional
mappings:

- *ignition-mask*: a map of fetch specifications (see section 1)
- *edge-buffer*: the thickness (feet) along the edge of the
  computational domain where ignitions cannot occur

*Note*: Nonzero values in the ignition mask are considered ignitable

Here's an example of specifiying ignition points using an ignition
mask from a geotiff file.

#+begin_src clojure
{:ignition-mask {:raster {:type :geotiff
                          :source "test/gridfire/resources/weather-test/ignition-mask.tif"}
                 :edge-buffer 98.4}}
#+end_src

*Note*: ignition-row and ignition-col must be omitted for this feature.

To initialize an existing burn perimeter from a raster, we have two
options. We can read rasters from a Postgresql database or a raster
file on disk. This behavior is controlled as follows:

Include the following mapping at the top level of the configuraiton
file:

- *ignition-layer*: a map of fetch specifications

For the fetch specifications include the following mappings:
- *type*: the method for fetching the layer
- *source*: the string input for the fetch method

Here's an example of fetching an intial burn perimeter from a
Postgresql database.

,*Note*: be sure to include the map of database connection (*:db-spec*) as
described in section 1.
,#+begin_src clojure
{:ignition-layer {:type   :postgis
                  :source "ignition.ign WHERE rid=1"}}
#+end_src

Here's an example of fetching an intial burn perimeter from a file on
disk
#+begin_src clojure
{:fetch-ignition-method :geotiff
 :ignition-layer        "test/gridfire/resources/ign.tif"}
#+end_src

GridFire makes use of clojure's multimethods to dispatch control to
different handlers for fetching ignition layers. The dispatch depends
on what is in the config file. Here's the namespace that implements
this functionality.

#+name: fetch.clj
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fetch.clj :padline no :no-expand :comments link
;; FIXME update when PR approved
(ns gridfire.fetch
  (:require [clojure.string           :as s]
            [gridfire.conversion      :as convert]
            [gridfire.magellan-bridge :refer [geotiff-raster-to-tensor]]
            [gridfire.postgis-bridge  :refer [postgis-raster-to-matrix]]
            [magellan.core            :refer [make-envelope]]
            [tech.v3.datatype         :as d]))

(set! *unchecked-math* :warn-on-boxed)

;;-----------------------------------------------------------------------------
;; Utilities
;;-----------------------------------------------------------------------------

(defn layer->envelope
  [{:keys [^double upperleftx
           ^double upperlefty
           ^double width
           ^double height
           ^double scalex
           ^double scaley]}
   srid]
  (make-envelope srid
                 upperleftx
                 (+ upperlefty (* height scaley))
                 (* width scalex)
                 (* -1.0 height scaley)))

;;-----------------------------------------------------------------------------
;; LANDFIRE
;;-----------------------------------------------------------------------------

(defn landfire-layer
  [{:keys [db-spec landfire-layers]} layer-name]
  (let [layer-spec                             (get landfire-layers layer-name)
        {:keys [type source units multiplier]} (if (map? layer-spec)
                                                 layer-spec
                                                 {:type   :postgis
                                                  :source layer-spec
                                                  :units  :metric})
        convert-fn                             (convert/get-units-converter layer-name
                                                                            units
                                                                            (or multiplier 1.0))
        datatype                               (if (= layer-name :fuel-model) ;TODO investigate why postgis
                                                 :int32                       ;     fuel-model is not converted
                                                 :float32)]                   ;     to int32
    (if (= type :postgis)
      (cond-> (postgis-raster-to-matrix db-spec source)
        convert-fn (update :matrix #(d/copy! (d/emap convert-fn datatype %) %)))
      (geotiff-raster-to-tensor source datatype convert-fn))))

;;-----------------------------------------------------------------------------
;; Initial Ignition
;;-----------------------------------------------------------------------------

(defn ignition-layer
  [{:keys [db-spec ignition-layer]}]
  (when ignition-layer
    (if-let [burn-values (:burn-values ignition-layer)]
      (let [{:keys [burned unburned]} burn-values
            convert-fn                (fn [x] (cond
                                                (= x burned)   1.0
                                                (= x unburned) 0.0
                                                :else          -1.0))]
        (if (= (:type ignition-layer) :postgis)
          (-> (postgis-raster-to-matrix db-spec (:source ignition-layer))
              (update :matrix #(d/copy! (d/emap convert-fn :float32 %) %)))
          (geotiff-raster-to-tensor (:source ignition-layer) :float32 convert-fn)))
      (if (= (:type ignition-layer) :postgis)
        (postgis-raster-to-matrix db-spec (:source ignition-layer))
        (geotiff-raster-to-tensor (:source ignition-layer))))))

;;-----------------------------------------------------------------------------
;; Ignition Mask
;;-----------------------------------------------------------------------------

(defn ignition-mask-layer
  [{:keys [db-spec random-ignition]}]
  (when (map? random-ignition)
    (let [spec (:ignition-mask random-ignition)]
      (if (= (:type spec) :postgis)
        (postgis-raster-to-matrix db-spec (:source spec))
        (geotiff-raster-to-tensor (:source spec))))))

;;-----------------------------------------------------------------------------
;; Weather
;;-----------------------------------------------------------------------------

(defn weather-layer
  "Returns a layer map for the given weather name. Units of available weather:
  - temperature:         fahrenheit
  - relative-humidity:   percent (0-100)
  - wind-speed-20ft:     mph
  - wind-from-direction: degreees clockwise from north"
  [{:keys [db-spec] :as config} weather-name]
  (let [weather-spec (get config weather-name)]
    (when (map? weather-spec)
      (let [{:keys [type source units multiplier]} weather-spec
            convert-fn                             (convert/get-units-converter weather-name units (or multiplier 1.0))]
        (if (= type :postgis)
          (cond-> (postgis-raster-to-matrix db-spec source)
            convert-fn (update :matrix #(d/copy! (d/emap convert-fn :float32 %) %)))
          (geotiff-raster-to-tensor source :float32 convert-fn))))))

;;-----------------------------------------------------------------------------
;; Moisture Layers
;;-----------------------------------------------------------------------------

(defn fuel-moisture-layer
  [{:keys [db-spec fuel-moisture]} category size]
  (let [spec (get-in fuel-moisture [category size])]
    (when (map? spec)
      (let [{:keys [type source units multiplier]} spec
            fuel-moisture-name                     (keyword (s/join "-" ["fuel-moisture" (name category) (name size)]))
            convert-fn                             (convert/get-units-converter fuel-moisture-name
                                                                                (or units :percent)
                                                                                (or multiplier 1.0))]
        (if (= type :postgis)
          (cond-> (postgis-raster-to-matrix db-spec source)
            convert-fn (update :matrix #(d/copy! (d/emap convert-fn :float32 %) %)))
          (geotiff-raster-to-tensor source :float32 convert-fn))))))

;;-----------------------------------------------------------------------------
;; Suppression Difficulty Index Layer
;;-----------------------------------------------------------------------------

(defn sdi-layer
  [{:keys [db-spec suppression]}]
  (when-let [{:keys [type source units multiplier] :as _spec} (:sdi-layer suppression)]
    (let [convert-fn (convert/get-units-converter :suppression
                                                  units
                                                  (or multiplier 1.0))]
      (if (= type :postgis)
        (cond-> (postgis-raster-to-matrix db-spec source)
          convert-fn (update :matrix #(d/copy! (d/emap convert-fn :float32 %) %)))
        (geotiff-raster-to-tensor source :float32 convert-fn)))))
#+end_src

** Section 3: Weather data from which to build simulation inputs

For all the options in this section, you may enter values in one of
three ways (as described in section 2): single, list, or range of
values.

#+begin_src clojure
{:temperature               (50 65 80)     ; (degrees Fahrenheit)
 :relative-humidity         (1 10 20)      ; (%)
 :wind-speed-20ft           (10 15 20)     ; (miles/hour)
 :wind-from-direction       (0 90 180 270) ; (degrees clockwise from north)
 :foliar-moisture           90}            ; (%)
#+end_src

Temperature, relative humidity, wind speed, and wind direction accepts
an additional type of input. GridFire allows us to use weather data
from rasters. To use weather data from raster we have two options.
This behavior is controlled as follows:

Include the following mapping at the top level of the configuraiton
file:

- *[weather-type]*: a map of fetch specifications

For the fetch specifications include the following mappings:
- *type*: the method for fetching the layer
- *source*: the string input for the fetch method

Here's an example of fetching weather rasters from a Postgresql database.
*Note*: be sure to include the map of database connection (*:db-spec*) as
described in section 1.
#+begin_src clojure
{:temperature         {:type   :postgis
                       :source "weather.tmpf WHERE rid=100"}
 :relative-humidity   {:type   :postgis
                       :source "weather.rh WHERE rid=100"}
 :wind-speed-20ft     {:type   :postgis
                       :source "weather.ws WHERE rid=100"}
 :wind-from-direction {:type   :postgis
                       :source "weather.wd WHERE rid=100"}}
#+end_src

Here's an example of fetching weather rasters from files on disk.
#+begin_src clojure
{:temperature         {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/tmpf_to_sample.tif"}
 :relative-humidity   {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/rh_to_sample.tif"}
 :wind-speed-20ft     {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/ws_to_sample.tif"}
 :wind-from-direction {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/d_to_sample.tif"}}
#+end_src

*NOTE:* Gridfire expects weather raster's resolution and the landfire's
resolution as designated by the `:cell-size` must be exact multiples
of one another. This means you may choose to use raster's of different
cell sizes to improve preformance.

Gridfire uses imperial units for its calculations. Gridfire optionally
allows us to use weather in different units and scale.

To specify the need for conversion from metric to imperial, include
the following mapping in the fetch specifications:

- *units*: keyword :metric

To specify the need for conversion from absolute to imperial, include

- *units*: keyword :absolute

#+begin_src clojure
{:temperture {:type   :geotiff
                :source "test/gridfire/resources/weather-test/tmpf_to_sample.tif"
                :units  :metric}}
#+end_src

** Section 4: Number of simulations and (optional) random seed perimeter

#+begin_src clojure
{:max-runtime               60             ; (minutes)
 :simulations               10
 :ellipse-adjustment-factor 1.0            ; (< 1.0 = more circular, > 1.0 = more elliptical)
 :random-seed 1234567890}                  ; long value (optional)
#+end_src

** Section 5: Outputs

Currently supported Geotiff layers for output
- fire-spread
- flame-length
- fire-line-intensity
- burn-history

To control the layers to output include the following mappings:
- *output-layers*: map of layers-name to timestep (in minutes) or the keyword `:final`
- *output-geotiff*: boolean

#+begin_src clojure
{:output-layers  {:fire-spread  10
                  :burn-history :final}
 :output-geotiff true}
#+end_src

The configuration above specify that we'd like to output one
firespread geotiff every 10 minutes in the simulation. For the burn
history we'd like to output the geotiff file at the final timestep of
the simulation.

*Note:* if entry for `:output-layers` is omitted but `:output-geotiff`
is set to true then Gridfire will output all layers above at the final
timestep.

Gridfire also supports a number of layers that aggregate data across
simulations.

To control the output of the burn probability layer, which is
calcualted as the number of times a cell burned divided by the number
of simulations, include the following mapping:

- *output-burn-probability*: timestep (in minutes) or keyword `:final`

#+begin_src clojure
{:output-burn-probability 10}
#+end_src

To specify the output of the flame length sum layer,
which is the sum of flame lengths across simulations, include
the following mapping:

- *output-flame-length-sum*: keyword `:max` or `:directional`

#+begin_src clojure
{:output-flame-length-sum :max}
#+end_src

To specify the output of the flame length max layer,
which is the max of flame lengths across simulations, include
the following mapping:

- *output-flame-length-max*: keyword `:max` or `:directional`

#+begin_src clojure
{:output-flame-length-max :directional}
#+end_src

To specify the output of the burn count layer, which is the number of
times a cell has burned across simulations, include the following
mapping:

- *output-burn-count*: boolean

#+begin_src clojure
{:output-burn-count true}
#+end_src


To specify the output of the spot count layer, which is the number of
times a spot ignition occured in a cell, include the following
mapping:

- *output-spot-count*: boolean

#+begin_src clojure
{:output-spot-count true}
#+end_src

Other output mappings:

#+begin_src clojure
{:outfile-suffix          "_tile_100"
 :output-landfire-inputs? true
 :output-pngs?            true
 :output-csvs?            true}
#+end_src

** Section 6: Perturbations

Gridfire supports applying perturbations to input rasters during
simulations in order to account for inherent uncertainty in the input
data. A uniform random sampling of values within a given range is used
to address these uncertanties.

To specify this in the config file include the following mappings:

- *perturbations:* a map of layer names to a map of perturbation configurations

#+begin_src clojure
{:perturbations {:canopy-height {:spatial-type :global
                                 :range        [-1.0 1.0]}}}
#+end_src

The above config specifies that a randomly selected value between -1.0
and 1.0 should be added to the canopy height value. This perturbation
will be applied globally to all cells. We could also, instead, specify
that each individual cell should be perturbed independently by setting
*:spatial-type* to *:pixel*. Finally, we can specify a non-constant
but smoother perturbation by setting *:spatial-type* to
*:smoothed-supergrid* along with some more configuration:

#+begin_src clojure
{:perturbations {:canopy-height {:spatial-type :smoothed-supergrid
                                 ;; Supergrid size param: number of subdivisions along each of the (b, i, j) axes
                                 ;; For a value of [sb si sj], the number of supergrid points will be (sb + 2)(si + 2)(sj + 2).
                                 ;; Recommendation: stick to small integers to avoid making the perturbation too wiggly.
                                 :gridfire.perturbation.smoothed-supergrid/supergrid-size [2 3 3]
                                 :range [-1. 1.]}}}
#+end_src

The above will behave similarly to a `:pixel` perturbation, except
that the i.i.d 'white noise' is sampled not on each individual pixel
of the space-time grid, but on a small-cardinality coarser-grained
'supergrid'; values for each individual pixel will then be resolved by
linear smoothing (i.e. averaging) between the 8 corners of the
supergrid cell containing it. *Limitations:* smoothed-supergrid
perturbations are not isotropic in space, nor are they spatially
homogeneous (generated perturbations will be smoother near the center
of supergrid cells than near their edges) - a potential direction to
address these shortcomings would be to generate the supergrid by
sampling an RBF Gaussian Process rather than i.i.d uniform
distributions.

Gridfire expects perturbations to be in imperial units. If these
perturbations are meant to be in metric, you must include an entry for
the units:

#+begin_src clojure
{:perturbations {:canopy-height {:spatial-type :global
                                 :range        [-1.0 1.0]
                                 :units        :metric}}}
#+end_src

For efficient execution, a custom pseudo-random generation algorithm
has been designed for ~{:spatial-type :pixel}~ perturbations,
which we call Hash-Determined Pixel Perturbations. The tradeoff of this
algorithm is efficient execution (very low cost in both time and memory usage)
at the expense of a potentially slightly degraded pseudo-randomness.

*** Hash-Determined Pixel Perturbations

Logically, ~{:spatial-type :pixel}~ perturbations consist of filling a discrete grid
with "white noise", by sampling one independent random variable per grid cell ('pixel').
Computationally, however, exhaustively realizing the whole grid of random perturbations
would be prohibitively expensive, and also wasteful, since oftentimes only a small
fraction of the perturbations are ever read by the simulation program - this is the case
when the perturbations must happen on Hour-band Ã X Ã Y grid (~[b i j]~ in code),
which can contain billions of cells, of which only a few millions will actually use their perturbation
during simulation.

One strategy we previously used is laziness: sampling the per-pixel random variables
as they are requested by the simulation, while maintaining a cache of the sampled values,
such that subsequent reads all see the same results.

We have found a more efficient strategy, however, which we dubbed /Hash-Determined Pixel Perturbations/:
HDPP approximates the \text{p}: \text{cell} \mapsto \text{perturbation} random function
by a composition of:

1. a deterministic hashing function \text{h}: \text{cell} \mapsto \text{hash-bucket},
   where \text{hash-bucket} is an integer between 0 and 2^d (say, 1024)
2. a random function \pi: \text{hash-bucket} \mapsto \text{perturbation}

Concretely, the computation of perturbations goes as follows:

1. Eagerly generate and store a 2^d-length array `h->perturb` of randomly-sampled pertubation values.
2. When the perturbation for cell ~[b i j]~ is requested, compute it as:

#+begin_src clojure
(fn resolve-perturbation [h->perturb b i j]
  (let [coords-hash (hash-pixel-coordinates b i j)]
    (nth h->perturb coords-hash)))
#+end_src

The above pseudo-code is very close to Gridfire's actual implementation code for HDPP,
which differs only to leverage more efficient JVM-primitive operations:

#+name: hdpp-implementation
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/perturbations/pixel/hash_determined.clj :no-expand :comments link
(ns gridfire.perturbations.pixel.hash-determined
  "Implements 'Hash-Determined Pixel Perturbations' (a name chosen by the GridFire team),
  an algorithm for efficiently emulating a 'white noise' random process on a large discrete grid,
  without having to generate a random perturbation for each cell of the entire grid,
  nor even for each requested cell."
  (:import (org.apache.commons.codec.digest MurmurHash3)))

(defn- is-power-of-2?
  [^long n]
  (if-not (pos-int? n)
    false
    (cond
      (= n 1) true
      (odd? n) false
      :else (recur (quot n 2)))))

(comment

  (def n 2r1000)
  (is-power-of-2? 2r1000)
  (is-power-of-2? 2r1010)

  *e)

(defn gen-hash->perturbation
  "Randomly populates an array mapping hash buckets to perturbations.

  Given:
  - n-buckets: a power of 2, the number of hash buckets,
  - gen-perturbation: a 1-arg function, accepting a hash bucket h (an integer < n-buckets)
    and returning a double, presumably sampled from the desired distribution of perturbations
    (Typically, the argument h will not be used, but it might serve to implement a form of reproducible
    pseudo-randomness.),

  returns an array of length n-buckets."
  ^doubles
  [n-buckets gen-perturbation]
  {:pre [(is-power-of-2? n-buckets)]}
  (into-array
    Double/TYPE
    (map
      gen-perturbation
      (range n-buckets))))

(defn resolve-perturbation-for-coords
  "Resolves the random perturbation for the grid cell ('pixel') of the supplied coordinates,
  using the h->perturb returned by #'gen-hash->perturbation.

  This function is deterministic: all the randomness happened when h->perturb was created."
  (^double [^doubles h->perturb ^long i ^long j]
   (let [n-buckets   (alength h->perturb)
         coords-hash (->
                       (->> (int 36791)
                            (MurmurHash3/hash32 i j))
                       (bit-and (dec n-buckets)))]
     (aget h->perturb coords-hash)))
  (^double [^doubles h->perturb ^long b ^long i ^long j]
   (let [n-buckets   (alength h->perturb)
         coords-hash (->
                       (->> (int 6053696) ;; randomly chosen seed.
                            ;; Compared to clojure.core's (hash) or (hash-combine) functions, MurmurHash3 buys us 2 things:
                            ;; 1. a guarantee of stable behaviour - the hashing functions will still return
                            ;; the same results after upgrading. That's not guaranteed with (hash).
                            ;; 2. Better performance, since those methods have primitive signatures.
                            ;; (this performance gain was empirically observed).
                            (MurmurHash3/hash32 i j)
                            (MurmurHash3/hash32 b))
                       (bit-and ;; fast modulo op - that's why we require n-buckets to be a power of 2.
                         ;; NOTE there is no significant efficiency gain to replacing this expr with a hardcoded int like 2r111111111.
                         (dec n-buckets)))]
     (aget h->perturb coords-hash))))
#+end_src

This approach is very efficient because we only generate and store 1024 random values
instead of one per requested pixel, and both Murmur3 hashing and small-constant-array lookup are very fast
operations.

Fundamentally, we are leveraging the fact that hashing functions like Murmur3 have been designed
to efficiently emulate a form of randomness.

With respect to simulation behaviour, such a perturbation process is effectively equivalent to
"truly random" perturbations. The use of a hashing function might slightly degrade the quality of the randomness,
creating more correlations than true IID randomness, but we have already accepted a similar tradeoff
by adopting pseudo-random generators like ~java.util.Random~. If our sampling algorithm for individual values
was truly random, we would indeed be reducing the entropy of our perturbations process
from billions of bits to a few thousands; but we're basing all this on deterministic pseudo-random generators anyway,
which means that the entropy is, strictly speaking, 0.
Visual inspection shows that an HDPP-generated perturbation map exhibits no more perceptible patterns
than an iid-generated one.

*** What to Expect from Perturbations

The typical intent of perturbations is to *propagate uncertainty*
about the inputs, which can mean:

1. verifying that simulation outcomes are robust to small changes in
   the inputs.
2. in a MCMC mindset, sampling the effects of inputs uncertainty on
   simulation outcomes.

WARNING: in order to achieve this last goal, *the probability
distribution of perturbations must be representative of your beliefs
about input uncertainty.* It's quite likely that independently-sampled
uniform distributions will fall short of this requirement, as
realistic uncertainty about weather and landscape will involve
non-uniform distributions and correlations between inputs; that is a
limitation of GridFire's *{:spatial-type :global}* perturbations, in
which case we recommend that you model your uncertainty using a
less-trivial sort of probability distribution (such as a multivariate
Gaussian, or mixture thereof) and sample from it upstream of GridFire.

*Pixel perturbations are also not good at modeling input uncertainty:*
while they do provide a form of spatial variability, that variability
is not realistic for modeling input uncertainty, as it ignores
potential spatial correlations between grid cells. For example,
inaccuracies in weather forecasting will never look like random i.i.d
noise (a.k.a "static"): the actual temperatures will be consistently
above or below the forecast on large contiguous regions. In other
words, pixel perturbations are not good at exploring the subspace of
credible inputs; they will mostly move the inputs in directions
orthogonal to that subspace.

However, *pixel perturbations can be useful for re-creating
small-scale spatial heterogeneity* (for example, the fact that canopy
height might not be constant even on a small scale). This concern is
orthogonal to propagating uncertainty: it's likely more relevant to
view it as a parameter for tuning the fire-spread algorithm. If
Percolation Theory and statistical physics are any indication, the
fire-spreading behavior might respond with sharp threshold effects to
varying the amplitude of pixel perturbations: if you are relying on
this, tune carefully.

** Section 7: Spotting

Gridfire supports spot fires.
To turn on spot ignitions include the key *spotting* at the top level of the
config file. The value is a map containg these required entries:

- *num-firebrands*: number of firebrands each torched tree will produce
- *decay-constant*: positive number
- *crown-fire-spotting-percent*: probability a crown fire ignition will spot fires

You may also choose to include surface fire spotting. This behavior is
controlled by including the following mappings under the *:spotting*
configuration:

- *surface-fire-spotting*: a map containing these required entries:
  - *spotting-percent*: a vector of fuel range and percent pairs where
    the fuel range is a tuple of integers representing the fuel model
    numbers and the percent is the percentage of surface fire igntion
    events that will spot fires
  - *critical-fire-line-intensity*: the fireline intensity below which
    surface fire spotting does not occur

#+begin_src clojure
{:spotting {:num-firebrands              [10 50]
            :decay-constant              0.005
            :crown-fire-spotting-percent 0.
            :surface-fires-spotting      {:spotting-percent             [[1 100] 1.0]
                                          :critical-fire-line-intensity 2000}}} ;(kW/m)
#+end_src

** Section 8: Fuel moisture data from which to build simulation inputs

GridFire allows us to optinally use fuel moisture from rasters instead
of calculating it (by default) from temperature and relative humidity.
To specifiy this feature include the following mappings at the top
level of the config file:

- *fuel-moisture*: a map of fuel moisture specicfiations

Fuel moisture specifications can be either a specification map as
described in section 1 or a ratio value.

#+begin_src clojure
{:fuel-moisture {:dead {:1hr   {:type   :geotiff
                                :source "test/gridfire/resources/weather-test/m1_to_sample.tif"}
                        :10hr  {:type   :geotiff
                                :source "test/gridfire/resources/weather-test/m10_to_sample.tif"}
                        :100hr {:type   :geotiff
                                :source "test/gridfire/resources/weather-test/m100_to_sample.tif"}}
                 :live {:woody      0.80
                        :herbaceous 0.30}}}
#+end_src

*Note*: Dead fuel moistures are expected to be multiband rasters and
live fuel moistures are singleband.

** Section 9: Optimization

Gridifre allows us use multithread processing to improve performance of the
simulation run. To specify the type of parallel strategy we'd like to use
include the following mapping at the top level of the config file:

- *parallel-strategy*: a keyword of the stratgey

#+begin_src clojure
{:parallel-strategy :within-fires}
#+end_src

Gridfire supports two types of paralleliztion. To prallelize:
- between ensemble of simulations use the keyword *:between-fires*
- within each ensemble member use the keyword *:within-fires*

** Section 10: Spread Algorithm

Gridfire uses the method of adaptive timestep and fractional distances cording
to Morais2001. Gridfire provides implementation for two interpretations on how
fractional distances are handled. When calculating the fractional distance of a
cell, there are 8 possible trajectories from which fire can spread into the
cell. When fractional distances are preserved between temesteps, they can be
individually tracked so that each trajectory does not have an effect on another,
or combined using the largest value among the trajectories. By default Gridfire
will track fractional distances individually.

To specify trajectories to have a cumulative effect include the following key
value pair at the top level of the config file:

- *:fractional-distance-combination* : the keyword `:sum`

** Section 11: Burn period

Gridfire allows you to specify a burn period in the day that fires are
allowed to burn. The burn period can be specified in two ways:

1. Explicitly setting the start and end clock.

2. Inferring the start and end clock by computing the approximate sunrise and sunset times
   using the geospatial data in the input landfire layer.

By default the burn-period is set from "00:00" to "24:00".

To explicitly set a burn period, you must include a few keys at the top
level of the config file.

1. *:burn-period* :: map with the following keys:

- *:start* :: a string with the format HH:MM
- *:end* :: a string with the format HH:MM

2. *:weather-start-timestamp* :: inst (timezone aware)

3. *:ignition-start-timestamp* :: inst (timezone aware)

#+begin_src clojure
{:burn-period               {:start "08:00", :end "9:00"}
 :weather-start-timestamp   #inst "2022-07-12T09:00:00.000+00:00"
 :ignition-start-timestamp  #inst "2022-07-12T09:05:00.000-00:00"}
#+end_src

To infer the burn period using the sunrise and sunset of the input
data, you must include a few keys at the top level of the config file.

1. *:burn-period-frac* :: A number from 0.0 to 1.0, positioning the
   center of the burn period in the interval between sunrise and
   sunset

2. *:burn-period-length* :: Length of the burn period, in hours

3. *:weather-start-timestamp* :: inst (timezone aware)

4. *:ignition-start-timestamp* :: inst (timezone aware)

#+begin_src clojure
{:burn-period-frac          0.6
 :burn-period-duration      10.0
 :weather-start-timestamp   #inst "2022-07-12T09:00:00.000+00:00"
 :ignition-start-timestamp  #inst "2022-07-12T09:05:00.000-00:00"}
#+end_src

** Section 12: Suppression

GridFire supports suppression of fires. Suppression emulates human
interventions reacting to fire spread by suppressing ('putting out')
chosen contiguous segments of the fire front, typically backing and
flanking fires. There are two suppression algorithms supported. Each
algorithm is aimed at computing the percentage of the perimeter of the
fire that should be contained. To enable suppression you must include
the key *:suppression* at the top level of the config file.

The *:suppression* key value is a map containing a different set of required
entries depending on which suppression algorithm you want to use.

One approach uses a suppression curve algorithm. To enable this include the
following:

- *suppression-dt* :: the time (in minutes) betweeen suppression events
- *suppression-coefficient* :: a constant calibration
  unit (see section 5.6.1)

#+begin_src clojure
{:suppression {:suppression-dt          60.0
               :suppression-coefficient 2.0}}
#+end_src

Another approach uses the suppression difficulty index raster layer.
To enable this include the following:

- *suppression-dt* :: the time (in minutes) betweeen suppression events
- *sdi-layer* :: a map of fetch specifications
- *sdi-sensitivity-to-difficulty* :: a calibration constant
- *sdi-reference-suppression-speed* :: a calibration constant
- *sdi-containment-overwhelming-area-growth-rate* :: a calibration constant

For more information about these parameters see section 5.6.2

#+begin_src clojure
:suppression {:suppression-dt                                60.0
              :sdi-layer                                     {:type       :geotiff
                                                              :source     "path/to/geotiff"
                                                              :multiplier 0.01}
              :sdi-sensitivity-to-difficulty                 2.0
              :sdi-containment-overwhelming-area-growth-rate 5000.0
              :sdi-reference-suppression-speed               100.0}
#+end_src

* Example Configuration Files

Here is a complete sample configuration for using landfire layers from our postigs enabled
database and initializing burn points from a range of values.

Here is a complete sample configuration for using LANDFIRE layers from
our PostGIS-enabled database with ignition points randomly sampled
from a range.

#+name: sample_postgis_config.edn
#+begin_src clojure :results silent :exports code :tangle ../resources/sample_postgis_config.edn :padline no :no-expand :comments link
{;; Section 1: Landscape data to be shared by all simulations
 :db-spec                   {:classname   "org.postgresql.Driver"
                             :subprotocol "postgresql"
                             :subname     "//localhost:5432/gridfire"
                             :user        "gridfire"
                             :password    "gridfire"}
 :landfire-layers            {:aspect             {:type   :postgis
                                                   :source "landfire.asp WHERE rid=100"}
                              :canopy-base-height {:type   :postgis
                                                   :source "landfire.cbh WHERE rid=100"}
                              :canopy-cover       {:type   :postgis
                                                   :source "landfire.cc WHERE rid=100"}
                              :canopy-height      {:type   :postgis
                                                   :source "landfire.ch WHERE rid=100"}
                              :crown-bulk-density {:type   :postgis
                                                   :source "landfire.cbd WHERE rid=100"}
                              :elevation          {:type   :postgis
                                                   :source "landfire.dem WHERE rid=100"}
                              :fuel-model         {:type   :postgis
                                                   :source "landfire.fbfm40 WHERE rid=100"}
                              :slope              {:type   :postgis
                                                   :source "landfire.slp WHERE rid=100"}}
 :srid                      "CUSTOM:900914"
 :cell-size                 98.425         ; (feet)

 ;; Section 2: Ignition data from which to build simulation inputs
 :ignition-row              [10 90]
 :ignition-col              [20 80]

 ;; Section 3: Weather data from which to build simulation inputs
 ;; For all options in this section, you may enter values in one of five ways:
 ;;   1. Single Value: 25
 ;;   2. List of Values: (2 17 9)
 ;;   3. Range of Values: [10 20]
 ;;   4. Raster from file on disk: {:type :geotiff :source "path/to/file/weather.tif"}
 ;;   5. Raster from Postgresql database: {:type :postgis :source "weather.ws WHERE rid=1"}
 ;;
 ;; If a single value is provided, it will be kept the same for all simulations.
 ;; For a list of values, the list will be randomly sampled from in each simulation.
 ;; For a range of values, the range [inclusive exclusive] will be randomly sampled from in each simulation.
 :temperature               (50 65 80)     ; (degrees Fahrenheit)
 :relative-humidity         (1 10 20)      ; (%)
 :wind-speed-20ft           (10 15 20)     ; (miles/hour)
 :wind-from-direction       (0 90 180 270) ; (degrees clockwise from north)
 :foliar-moisture           90             ; (%)

 ;; Section 4: Number of simulations and (optional) random seed parameter
 :max-runtime               60             ; (minutes)
 :ellipse-adjustment-factor 1.0            ; (< 1.0 = more circular, > 1.0 = more elliptical)
 :simulations               10
 :random-seed               1234567890     ; long value (optional)

 ;; Section 5: Types and names of outputs
 :outfile-suffix            "_tile_100"
 :output-landfire-inputs?   true
 :output-geotiffs?          true
 :output-pngs?              true
 :output-csvs?              true}
#+end_src

Here is a complete sample configuration for reading both the LANDFIRE
layers, initial burn perimeter, and weather layers from GeoTIFF
files on disk.

#+name: sample_geotiff_config.edn
#+begin_src clojure :results silent :exports code :tangle ../resources/sample_geotiff_config.edn :padline no :no-expand :comments link
{;; Section 1: Landscape data to be shared by all simulations
 :landfire-layers           {:aspect             {:type   :geotiff
                                                  :source "test/gridfire/resources/asp.tif"}
                             :canopy-base-height {:type   :geotiff
                                                  :source "test/gridfire/resources/cbh.tif"}
                             :canopy-cover       {:type   :geotiff
                                                  :source "test/gridfire/resources/cc.tif"}
                             :canopy-height      {:type   :geotiff
                                                  :source "test/gridfire/resources/ch.tif"}
                             :crown-bulk-density {:type   :geotiff
                                                  :source "test/gridfire/resources/cbd.tif"}
                             :elevation          {:type   :geotiff
                                                  :source "test/gridfire/resources/dem.tif"}
                             :fuel-model         {:type   :geotiff
                                                  :source "test/gridfire/resources/fbfm40.tif"}
                             :slope              {:type   :geotiff
                                                  :source "test/gridfire/resources/slp.tif"}}
 :srid                      "CUSTOM:900914"
 :cell-size                 98.425         ; (feet)

 ;; Section 2: Ignition data from which to build simulation inputs
 :ignition-layer            {:type   :geotiff
                             :source "test/gridfire/resources/ign.tif"}

 ;; Section 3: Weather data from which to build simulation inputs
 ;; For all options in this section, you may enter values in one of five ways:
 ;;   1. Single Value: 25
 ;;   2. List of Values: (2 17 9)
 ;;   3. Range of Values: [10 20]
 ;;   4. Raster from file on disk: {:type :geotiff :source "path/to/file/weather.tif"}
 ;;   5. Raster from Postgresql database: {:type :postgis :source "weather.ws WHERE rid=1"}
 ;;
 ;; If a single value is provided, it will be kept the same for all simulations.
 ;; For a list of values, the list will be randomly sampled from in each simulation.
 ;; For a range of values, the range [inclusive exclusive] will be randomly sampled from in each simulation.

 :temperature         {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/tmpf_to_sample.tif"} ; (degrees Fahrenheit)
 :relative-humidity   {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/rh_to_sample.tif"}   ; (%)
 :wind-speed-20ft     {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/ws_to_sample.tif"}   ; (miles/hour)
 :wind-from-direction {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/wd_to_sample.tif"}   ; (degrees cw from north)
 :foliar-moisture     90                                                                  ; (%)

 ;; Section 4: Number of simulations and (optional) random seed parameter
 :max-runtime               60             ; (minutes)
 :ellipse-adjustment-factor 1.0            ; (< 1.0 = more circular, > 1.0 = more elliptical)
 :simulations               10
 :random-seed               1234567890     ; long value (optional)

 ;; Section 5: Types and names of outputs
 :outfile-suffix            "_from_raster_ignition"
 :output-landfire-inputs?   true
 :output-geotiffs?          true
 :output-pngs?              true
 :output-csvs?              true}
#+end_src

This concludes our discussion of GridFire's command line interface.

#+LATEX: \bibliographystyle{plainnat}
#+LATEX: \bibliography{GridFire}

* Monte Carlo Simulation                                           :noexport:

#+name: monte-carlo-simulation
#+begin_src clojure :results silent :exports none :tangle ../src/gridfire/monte_carlo.clj :padline no :no-expand :comments link
(ns gridfire.monte-carlo
  (:require [clojure.java.io :as io]
            [clojure.data.csv :as csv]
            [clojure.java.jdbc :as jdbc]
            [clojure.core.reducers :as r]
            [gridfire.surface-fire :refer [degrees-to-radians]]
            [gridfire.fire-spread :refer [random-cell run-fire-spread]]
            [gridfire.postgis-bridge :refer [postgis-raster-to-matrix]]
            [tech.v3.datatype :as d]
            [tech.v3.datatype.functional :as dfn]
            [tech.v3.tensor :as t]))

(defn postprocess-simulation-results
  [wrf-cell-id lon lat cell-offset-in-neighborhood output-directory results-table]
  (let [num-fires (count results-table)]
    (with-open [out-file (io/writer (io/file output-directory (str "all-fires-" wrf-cell-id ".csv")))]
      (csv/write-csv out-file
                     (cons ["wrf_cell_id" "lon" "lat" "landfire_y" "landfire_x" "offwig_percentile"
                            "ws_20ft_mph" "wdir" "mparam" "lw_moisture" "eaf" "fire_size_ac" "flame_length_mean"
                            ;; "flame_length_stddev" "fire_volume" "fire_shape"]
                            "fire_volume" "fire_shape"]
                           (mapv (fn [{:keys [ignition-site weather-sample wind-speed-20ft wind-from-direction
                                              equilibrium-moisture lw-moisture eaf fire-size flame-length-mean
                                              ;; flame-length-stddev fire-volume fire-shape]}]
                                              fire-volume fire-shape]}]
                                   (let [local-site     (mop/- ignition-site cell-offset-in-neighborhood)
                                         wrf-percentile (- 100.0 (/ weather-sample 36.0))]
                                     [wrf-cell-id
                                      lon
                                      lat
                                      (local-site 0)
                                      (local-site 1)
                                      wrf-percentile
                                      wind-speed-20ft
                                      wind-from-direction
                                      equilibrium-moisture
                                      lw-moisture
                                      eaf
                                      fire-size
                                      flame-length-mean
                                      ;; flame-length-stddev
                                      fire-volume
                                      fire-shape]))
                                 (sort-by :ignition-site results-table)))))
    (format "%s,%s,%s,%.2f,%.2f,%.2f,%.2f\n"
            wrf-cell-id lon lat
            (/ (transduce (map :fire-size)         + 0.0 results-table) num-fires)
            (/ (transduce (map :flame-length-mean) + 0.0 results-table) num-fires)
            (/ (transduce (map :fire-volume)       + 0.0 results-table) num-fires)
            (/ (transduce (map :fire-shape)        + 0.0 results-table) num-fires))))

(defn cells-to-acres
  [cell-size num-cells]
  (let [acres-per-cell (/ (* cell-size cell-size) 43560.0)]
    (* acres-per-cell num-cells)))

(defn compute-fire-behavior-metrics!
  [weather-readings lw-moisture burn-duration cell-size landfire-layers
   ellipse-adjustment-factor ignition-site weather-sample]
  (let [weather-reading      (get weather-readings weather-sample)
        wind-speed-20ft      (weather-reading :ws)     ;; mph
        wind-from-direction  (mod (+ 15 (weather-reading :wd)) 360) ;; degrees (+15 for WRF->AEA warping)
        equilibrium-moisture (weather-reading :mparam) ;; % (0-100)
        fuel-moisture        {:dead {:1hr        (* (+ equilibrium-moisture 0.2) 0.01)
                                     :10hr       (* (+ equilibrium-moisture 1.5) 0.01)
                                     :100hr      (* (+ equilibrium-moisture 2.5) 0.01)}
                              :live {:herbaceous 0.30
                                     :woody      (* lw-moisture 0.01)}}
        foliar-moisture      0.90
        fire-results         (run-fire-spread burn-duration cell-size landfire-layers
                                              wind-speed-20ft wind-from-direction
                                              fuel-moisture foliar-moisture
                                              ellipse-adjustment-factor ignition-site)]
    (if fire-results
      (let [flame-lengths       (filterv pos? (t/tensor->buffer (:flame-length-matrix fire-results)))
            burned-cells        (count flame-lengths)
            fire-size           (cells-to-acres cell-size burned-cells)
            flame-length-mean   (/ (dfn/sum flame-lengths) burned-cells)
            ;; flame-length-stddev (->> flame-lengths
            ;;                          (d/emap #(Math/pow (- flame-length-mean %) 2.0) nil)
            ;;                          (dfn/sum)
            ;;                          (#(/ % burned-cells))
            ;;                          (Math/sqrt))]
            ]
        {:ignition-site        ignition-site
         :weather-sample       weather-sample
         :wind-speed-20ft      wind-speed-20ft
         :wind-from-direction  wind-from-direction
         :equilibrium-moisture equilibrium-moisture
         :lw-moisture          lw-moisture
         :eaf                  ellipse-adjustment-factor
         :fire-size            fire-size
         :flame-length-mean    flame-length-mean
         ;; :flame-length-stddev  flame-length-stddev
         :fire-volume          (* fire-size flame-length-mean)
         :fire-shape           (/ fire-size flame-length-mean)})
      {:ignition-site        ignition-site
       :weather-sample       weather-sample
       :wind-speed-20ft      wind-speed-20ft
       :wind-from-direction  wind-from-direction
       :equilibrium-moisture equilibrium-moisture
       :lw-moisture          lw-moisture
       :eaf                  ellipse-adjustment-factor
       :fire-size            0.0
       :flame-length-mean    0.0
       ;; :flame-length-stddev  0.0
       :fire-volume          0.0
       :fire-shape           0.0})))

(defn run-monte-carlo-fire-spread
  "Returns a vector of maps with the following fields:
   {:ignition-site :weather-sample :wind-speed-20ft :wind-from-direction :equilibrium-moisture
    :eaf :fire-size :flame-length-mean :flame-length-stddev :fire-volume :fire-shape}
   Inputs include:
   - landfire-layers  (map of core.matrix 2D double arrays)
                      {:elevation          m
                       :slope              degrees
                       :aspect             degrees from north
                       :fuel-model         category
                       :canopy-height      m
                       :canopy-base-height m
                       :crown-bulk-density kg/m^3
                       :canopy-cover       % (0-100)}
   - cell-size        cell size of matrices in landfire-layers (ft)
   - ignition-sites   (vector of [i j] points)
   - weather-readings (vector of weather records)
                      [{:ws mph :wd degrees :mparam %} ...]
   - lw-moisture      live woody fuel moisture % (0-100+)
   - samples-per-site (no-arg fn that produces a sequence of indices into weather-readings)
   - burn-duration    maximum time to allow each fire to spread (mins)
   - ellipse-adjustment-factor (< 1.0 = more circular, > 1.0 = more elliptical)"
  [landfire-layers cell-size ignition-sites weather-readings lw-moisture max-wrf-sample-index
   burn-duration ellipse-adjustment-factor]
  (let [landfire-layers (assoc landfire-layers
                               :elevation          (d/clone (d/emap #(* % 3.28) nil (landfire-layers :elevation))) ; m -> ft
                               :slope              (d/clone (d/emap #(Math/tan (degrees-to-radians %)) nil (landfire-layers :slope))) ; degrees -> %
                               :canopy-height      (d/clone (d/emap #(* % 3.28) nil (landfire-layers :canopy-height))) ; m -> ft
                               :canopy-base-height (d/clone (d/emap #(* % 3.28) nil (landfire-layers :canopy-base-height))) ; m -> ft
                               :crown-bulk-density (d/clone (d/emap #(* % 0.0624) nil (landfire-layers :crown-bulk-density))))] ; kg/m^3 -> lb/ft^3
    (mapv (fn [ignition-site]
            (let [weather-sample (rand-int max-wrf-sample-index)]
              (compute-fire-behavior-metrics! weather-readings lw-moisture burn-duration cell-size
                                              landfire-layers ellipse-adjustment-factor ignition-site weather-sample)))
          ignition-sites)))

(defn fetch-wrf-cell-ids
  "Returns a vector of all unique wrf_cell_id strings."
  [db-spec]
  (let [query (str "SELECT j_i AS wrf_cell_id, lon, lat, lw_moisture"
                   "  FROM weather.wrf_points_ca"
                   "  ORDER BY lw_moisture DESC")]
    (jdbc/with-db-transaction [conn db-spec]
      (vec (jdbc/query conn [query])))))

(defn fetch-extreme-weather-readings
  "Returns a vector of maps for each of the top 2% weather readings by
   FFWI with these units:
   {:rank   1-73 (1 = 100th percentile, 73 = 98th percentile)
    :ws     mph (* 0.87 to adjust from 10m winds to 20ft winds)
    :wd     degrees from north
    :mparam 10 * % (0-1000)}"
  [db-spec wrf-cell-id]
  (let [query (str "SELECT rank, 0.87*ows_mph AS ws, wd_deg AS wd, mparam::int AS mparam"
                   "  FROM weather.toptwo_full_daily"
                   "  WHERE j_i_wrf_cacut='" wrf-cell-id "'"
                   "  ORDER BY rank")]
     (jdbc/with-db-transaction [conn db-spec]
       (vec (jdbc/query conn [query])))))

(defn fetch-midrange-weather-readings
  "Returns a vector of maps for each of the 74-76% weather readings by
   FFWI with these units:
   {:rank   1-73 (1 = 100th percentile, 73 = 98th percentile)
    :ws     mph (* 0.87 to adjust from 10m winds to 20ft winds)
    :wd     degrees from north
    :mparam 10 * % (0-1000)}"
  [db-spec wrf-cell-id]
  (let [query (str "SELECT rank, 0.87*ows_mph AS ws, wd_deg AS wd, mparam::int AS mparam"
                   "  FROM weather.midtwo_full_daily"
                   "  WHERE j_i_wrf_cacut='" wrf-cell-id "'"
                   "  ORDER BY rank")]
     (jdbc/with-db-transaction [conn db-spec]
       (vec (jdbc/query conn [query])))))

(defn fetch-landfire-data
  "Returns a map of LANDFIRE rasters as core.matrix 2D double arrays:
   {:elevation          m
    :slope              degrees
    :aspect             degrees
    :fuel-model         category
    :canopy-height      m
    :canopy-base-height m
    :crown-bulk-density kg/m^3
    :canopy-cover       % (0-100)}"
  [db-spec wrf-cell-id]
  (let [landfire-data
        {:elevation          (:matrix (postgis-raster-to-matrix db-spec (str "landfire.dem_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :slope              (:matrix (postgis-raster-to-matrix db-spec (str "landfire.slp_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :aspect             (:matrix (postgis-raster-to-matrix db-spec (str "landfire.asp_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :fuel-model         (:matrix (postgis-raster-to-matrix db-spec (str "fuel_model.fmod_iet_veg2015_wrf_tiles WHERE j_i='" wrf-cell-id "'")))
         ;; :fuel-model         (:matrix (postgis-raster-to-matrix db-spec (str "fuel_model.fmod_reax_v2005_wrf_tiles  WHERE j_i='" wrf-cell-id "'")))
         :canopy-height      (:matrix (postgis-raster-to-matrix db-spec (str "landfire.ch_wrf_tiles                 WHERE j_i='" wrf-cell-id "'")))
         :canopy-base-height (:matrix (postgis-raster-to-matrix db-spec (str "landfire.cbh_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :crown-bulk-density (:matrix (postgis-raster-to-matrix db-spec (str "landfire.cbd_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :canopy-cover       (:matrix (postgis-raster-to-matrix db-spec (str "landfire.cc_wrf_tiles                 WHERE j_i='" wrf-cell-id "'")))}]
    (if (not-any? nil? (vals landfire-data))
      landfire-data)))

(defn read-wrf-cells-list [clj-file start end]
  (-> (slurp clj-file)
      (read-string)
      (subvec start end)))

(defn launch-calfire-monte-carlo-simulation
  [db-spec output-directory wrf-cells-file start end fold-bin-size]
  ;; 1. Read in a list of wrf-cell-ids to process [{:wrf_cell_id :lon :lat :lw_moisture}...]
  ;; 2. Iterate through the wrf-cell-ids sequentially
  ;;    1. Load the live woody fuel moisture
  ;;    2. Load the top 2% extreme FFWI weather dataset as a vector of maps
  ;;    3. Load the LANDFIRE data
  ;;    4. Randomly select 1000 distinct LANDFIRE ignition-sites as a sequence of [i j] points
  ;;    5. Run run-monte-carlo-fire-spread for this WRF cell
  ;;    6. Write results-table to disk as a CSV
  (let [landfire-cell-size          98.425 ;; ft
        calfire-burn-duration       60.0   ;; mins
        max-wrf-sample-index        73
        ellipse-adjustment-factor   1.0
        cell-offset-in-neighborhood [84 83]
        num-ignitions               1000]
    (->> (read-wrf-cells-list wrf-cells-file start end)
         (r/filter (fn [{:keys [wrf_cell_id]}]
                     (not (.exists (io/file output-directory (str "all-fires-" wrf_cell_id ".csv"))))))
         (r/map (fn [{:keys [wrf_cell_id lon lat lw_moisture]}]
                  (try (let [ignition-sites   (into []
                                                    (comp (distinct) (take num-ignitions))
                                                    (repeatedly #(mop/+ cell-offset-in-neighborhood (random-cell 84 83))))
                             weather-readings (fetch-midrange-weather-readings db-spec wrf_cell_id)]
                         (when-let [landfire-data (fetch-landfire-data db-spec wrf_cell_id)]
                           (->> (run-monte-carlo-fire-spread landfire-data landfire-cell-size ignition-sites weather-readings lw_moisture
                                                             max-wrf-sample-index calfire-burn-duration ellipse-adjustment-factor)
                                (postprocess-simulation-results wrf_cell_id lon lat cell-offset-in-neighborhood output-directory))))
                       (catch Exception e (println "Exception in" wrf_cell_id "->" e)))))
         (r/remove nil?)
         (r/fold fold-bin-size r/cat r/append!)
         (cons "wrf_cell_id,lon,lat,fire_size,flame_length,fire_volume,fire_shape")
         (spit (io/file output-directory "all-fires-summary.csv")))))

(comment
  (spit "/data/CALFIRE_MAP1_RUN6/inputs/wrf_cells_to_process.clj"
        (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                             :subprotocol "postgresql"
                             :subname     "//iwap03:5432/calfire"
                             :user        "gridfire"}))

  (spit "/data/CALFIRE_MAP1_RUN6/inputs/wrf_cells_to_process.clj"
        (filterv (fn [{:keys [wrf_cell_id]}]
                   (not (.exists (io/file "/data/CALFIRE_MAP1_RUN6/outputs" (str "all-fires-" wrf_cell_id ".csv")))))
                 (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                                      :subprotocol "postgresql"
                                      :subname     "//iwap03:5432/calfire"
                                      :user        "gridfire"})))

  (spit "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
        (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                             :subprotocol "postgresql"
                             :subname     "//iwap03:5432/calfire"
                             :user        "gridfire"}))

  (spit "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
        (filterv (fn [{:keys [wrf_cell_id]}]
                   (not (.exists (io/file "/data/IWAP_GRIDFIRE_RUNS/outputs" (str "all-fires-" wrf_cell_id ".csv")))))
                 (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                                      :subprotocol "postgresql"
                                      :subname     "//iwap03:5432/calfire"
                                      :user        "gridfire"})))

  ;; iwap02
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//iwap03:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   0 6000 30)

  ;; iwap03
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//localhost:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   6000 18000 100)

  ;; iwap04
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//iwap03:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   18000 30000 100)

  ;; iwap05
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//iwap03:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   30000 41423 100))
#+end_src
